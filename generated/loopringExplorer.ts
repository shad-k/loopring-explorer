/* eslint-disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigDecimal: any;
  BigInt: any;
  Bytes: any;
};

export type Account = {
  /** Address linked to the account ID */
  address: Scalars['Bytes'];
  /** List of all the balances for each specific token the account has interacted with */
  balances: Array<AccountTokenBalance>;
  /** L2 transaction internalID where the account was first created and linked to an address. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the account was first created and linked to an address */
  createdAtTransaction: Transaction;
  /** Internal ID used in the L2 transactions. Users will be of type User and have an ID > 10000. Pools will be of type Pool and have an id < 10000. ProtocolAccount is a special account with ID 0 which handles all token balances generated by protocol fees. */
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt for sorting purposes */
  internalID: Scalars['BigInt'];
  /** L2 transaction internalID that last updated the account entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the account entity */
  lastUpdatedAtTransaction: Transaction;
  /** List of all the AccountNFTSlot entities that this account has. Those slots can be empty but will only exist if they held an NFT at some point. */
  slots: Array<AccountNftSlot>;
  /** L2 transactions that involved this account */
  transactions: Array<Transaction>;
};

export type AccountBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type AccountSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type AccountTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type AccountNftSlot = {
  __typename?: 'AccountNFTSlot';
  /** Owner of this slot */
  account: Account;
  /** Amount of copies of this NonFungibleToken saved in this slot. */
  balance: Scalars['BigInt'];
  /** L2 transaction internalID where the slot was first created. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the slot was first created */
  createdAtTransaction: Transaction;
  /** ID is compounded from the account ID and the token ID used as an NFT slot. */
  id: Scalars['ID'];
  /** L2 transaction internalID that last updated the slot entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the slot entity */
  lastUpdatedAtTransaction: Transaction;
  /** NonFungibleToken saved in this slot. Null if empty */
  nft?: Maybe<NonFungibleToken>;
  /** List of all the transactions that this particular NFT was a part of */
  transactions: Array<TransactionNft>;
};

export type AccountNftSlotTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TransactionNft_Filter>;
};

export type AccountNftSlot_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  nft?: InputMaybe<Scalars['String']>;
  nft_?: InputMaybe<NonFungibleToken_Filter>;
  nft_contains?: InputMaybe<Scalars['String']>;
  nft_contains_nocase?: InputMaybe<Scalars['String']>;
  nft_ends_with?: InputMaybe<Scalars['String']>;
  nft_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nft_gt?: InputMaybe<Scalars['String']>;
  nft_gte?: InputMaybe<Scalars['String']>;
  nft_in?: InputMaybe<Array<Scalars['String']>>;
  nft_lt?: InputMaybe<Scalars['String']>;
  nft_lte?: InputMaybe<Scalars['String']>;
  nft_not?: InputMaybe<Scalars['String']>;
  nft_not_contains?: InputMaybe<Scalars['String']>;
  nft_not_contains_nocase?: InputMaybe<Scalars['String']>;
  nft_not_ends_with?: InputMaybe<Scalars['String']>;
  nft_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nft_not_in?: InputMaybe<Array<Scalars['String']>>;
  nft_not_starts_with?: InputMaybe<Scalars['String']>;
  nft_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nft_starts_with?: InputMaybe<Scalars['String']>;
  nft_starts_with_nocase?: InputMaybe<Scalars['String']>;
  transactions_?: InputMaybe<TransactionNft_Filter>;
};

export enum AccountNftSlot_OrderBy {
  Account = 'account',
  Balance = 'balance',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  Id = 'id',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  Nft = 'nft',
  Transactions = 'transactions',
}

export type AccountTokenBalance = {
  __typename?: 'AccountTokenBalance';
  /** Link to the Account entity. Can be a Pool or User entity */
  account: Account;
  balance: Scalars['BigInt'];
  dailyData: Array<AccountTokenBalanceDailyData>;
  /** ID is recreated following this pattern: <ACCOUNT ID>-<TOKEN ID>. Example: 10001-1 */
  id: Scalars['ID'];
  /** Link to the Token entity. Holds all details of the token itself. */
  token: Token;
  transactions: Array<Transaction>;
  weeklyData: Array<AccountTokenBalanceWeeklyData>;
};

export type AccountTokenBalanceDailyDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
};

export type AccountTokenBalanceTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type AccountTokenBalanceWeeklyDataArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export type AccountTokenBalanceDailyData = {
  __typename?: 'AccountTokenBalanceDailyData';
  /** Link to the Account entity. Can be a Pool or User entity */
  account: Account;
  /** Link to the original AccountTokenBalance entity. */
  accountTokenBalance: AccountTokenBalance;
  /** Latest value for balance for this AccountTokenBalance entity on this specific day. Coincides with balanceClose */
  balance: Scalars['BigInt'];
  /** Last update of balance for this AccountTokenBalance entity on this specific day */
  balanceClose: Scalars['BigInt'];
  /** Highest balance for this AccountTokenBalance entity on this specific day */
  balanceHigh: Scalars['BigInt'];
  /** Lowest balance for this AccountTokenBalance entity on this specific day */
  balanceLow: Scalars['BigInt'];
  /** Balance for this AccountTokenBalance entity when it was created. */
  balanceOpen: Scalars['BigInt'];
  /** Timestamp of the end of the day. Timezone -> UTC */
  dayEnd: Scalars['BigInt'];
  /** Day number is the amount of days since the start block of Loopring 3.6 (block 11149814) */
  dayNumber: Scalars['Int'];
  /** Timestamp of the start of the day. Timezone -> UTC */
  dayStart: Scalars['BigInt'];
  /** The ID follows this pattern: <ACCOUNT TOKEN BALANCE ID>-<DAY NUMBER>. */
  id: Scalars['ID'];
  /** Link to the Token entity. Holds all details of the token itself. */
  token: Token;
};

export type AccountTokenBalanceDailyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountTokenBalance?: InputMaybe<Scalars['String']>;
  accountTokenBalance_?: InputMaybe<AccountTokenBalance_Filter>;
  accountTokenBalance_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_lt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_lte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_not_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balanceClose?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceClose_lt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_lte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow_lt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_lte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd_lt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_lte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayNumber?: InputMaybe<Scalars['Int']>;
  dayNumber_gt?: InputMaybe<Scalars['Int']>;
  dayNumber_gte?: InputMaybe<Scalars['Int']>;
  dayNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  dayNumber_lt?: InputMaybe<Scalars['Int']>;
  dayNumber_lte?: InputMaybe<Scalars['Int']>;
  dayNumber_not?: InputMaybe<Scalars['Int']>;
  dayNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  dayStart?: InputMaybe<Scalars['BigInt']>;
  dayStart_gt?: InputMaybe<Scalars['BigInt']>;
  dayStart_gte?: InputMaybe<Scalars['BigInt']>;
  dayStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayStart_lt?: InputMaybe<Scalars['BigInt']>;
  dayStart_lte?: InputMaybe<Scalars['BigInt']>;
  dayStart_not?: InputMaybe<Scalars['BigInt']>;
  dayStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum AccountTokenBalanceDailyData_OrderBy {
  Account = 'account',
  AccountTokenBalance = 'accountTokenBalance',
  Balance = 'balance',
  BalanceClose = 'balanceClose',
  BalanceHigh = 'balanceHigh',
  BalanceLow = 'balanceLow',
  BalanceOpen = 'balanceOpen',
  DayEnd = 'dayEnd',
  DayNumber = 'dayNumber',
  DayStart = 'dayStart',
  Id = 'id',
  Token = 'token',
}

export type AccountTokenBalanceWeeklyData = {
  __typename?: 'AccountTokenBalanceWeeklyData';
  /** Link to the Account entity. Can be a Pool or User entity */
  account: Account;
  /** Link to the original AccountTokenBalance entity. */
  accountTokenBalance: AccountTokenBalance;
  /** Latest value for balance for this AccountTokenBalance entity on this specific week. Coincides with balanceClose */
  balance: Scalars['BigInt'];
  /** Last update of balance for this AccountTokenBalance entity on this specific week */
  balanceClose: Scalars['BigInt'];
  /** Highest balance for this AccountTokenBalance entity on this specific week */
  balanceHigh: Scalars['BigInt'];
  /** Lowest balance for this AccountTokenBalance entity on this specific week */
  balanceLow: Scalars['BigInt'];
  /** Balance for this AccountTokenBalance entity when it was created. */
  balanceOpen: Scalars['BigInt'];
  /** The ID follows this pattern: <ACCOUNT TOKEN BALANCE ID>-<WEEK NUMBER>. */
  id: Scalars['ID'];
  /** Link to the Token entity. Holds all details of the token itself. */
  token: Token;
  /** Timestamp of the end of the week. Timezone -> UTC */
  weekEnd: Scalars['BigInt'];
  /** Week number is the amount of weeks since the start block of Loopring 3.6 (block 11149814) */
  weekNumber: Scalars['Int'];
  /** Timestamp of the start of the week. Timezone -> UTC */
  weekStart: Scalars['BigInt'];
};

export type AccountTokenBalanceWeeklyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountTokenBalance?: InputMaybe<Scalars['String']>;
  accountTokenBalance_?: InputMaybe<AccountTokenBalance_Filter>;
  accountTokenBalance_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_gte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_lt?: InputMaybe<Scalars['String']>;
  accountTokenBalance_lte?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenBalance_not_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenBalance_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balanceClose?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_gte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceClose_lt?: InputMaybe<Scalars['BigInt']>;
  balanceClose_lte?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not?: InputMaybe<Scalars['BigInt']>;
  balanceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not?: InputMaybe<Scalars['BigInt']>;
  balanceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_gte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceLow_lt?: InputMaybe<Scalars['BigInt']>;
  balanceLow_lte?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not?: InputMaybe<Scalars['BigInt']>;
  balanceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not?: InputMaybe<Scalars['BigInt']>;
  balanceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  weekEnd?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd_lt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_lte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekNumber?: InputMaybe<Scalars['Int']>;
  weekNumber_gt?: InputMaybe<Scalars['Int']>;
  weekNumber_gte?: InputMaybe<Scalars['Int']>;
  weekNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  weekNumber_lt?: InputMaybe<Scalars['Int']>;
  weekNumber_lte?: InputMaybe<Scalars['Int']>;
  weekNumber_not?: InputMaybe<Scalars['Int']>;
  weekNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  weekStart?: InputMaybe<Scalars['BigInt']>;
  weekStart_gt?: InputMaybe<Scalars['BigInt']>;
  weekStart_gte?: InputMaybe<Scalars['BigInt']>;
  weekStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekStart_lt?: InputMaybe<Scalars['BigInt']>;
  weekStart_lte?: InputMaybe<Scalars['BigInt']>;
  weekStart_not?: InputMaybe<Scalars['BigInt']>;
  weekStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum AccountTokenBalanceWeeklyData_OrderBy {
  Account = 'account',
  AccountTokenBalance = 'accountTokenBalance',
  Balance = 'balance',
  BalanceClose = 'balanceClose',
  BalanceHigh = 'balanceHigh',
  BalanceLow = 'balanceLow',
  BalanceOpen = 'balanceOpen',
  Id = 'id',
  Token = 'token',
  WeekEnd = 'weekEnd',
  WeekNumber = 'weekNumber',
  WeekStart = 'weekStart',
}

export type AccountTokenBalance_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dailyData_?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  transactions_?: InputMaybe<Transaction_Filter>;
  weeklyData_?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export enum AccountTokenBalance_OrderBy {
  Account = 'account',
  Balance = 'balance',
  DailyData = 'dailyData',
  Id = 'id',
  Token = 'token',
  Transactions = 'transactions',
  WeeklyData = 'weeklyData',
}

export type AccountUpdate = Transaction & {
  __typename?: 'AccountUpdate';
  /** [RAW L2 DATA] Account ID of the user account updated */
  accountID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken: Token;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Nonce */
  nonce: Scalars['Int'];
  /** [RAW L2 DATA] Address of the user account updated */
  owner: Scalars['String'];
  /** [RAW L2 DATA] Updated public key for the account */
  publicKey: Scalars['String'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
  /** [RAW L2 DATA] Update type */
  updateType: Scalars['Int'];
  /** User account entity updated in this transaction */
  user: User;
};

export type AccountUpdateAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type AccountUpdateTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type AccountUpdate_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountID?: InputMaybe<Scalars['Int']>;
  accountID_gt?: InputMaybe<Scalars['Int']>;
  accountID_gte?: InputMaybe<Scalars['Int']>;
  accountID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountID_lt?: InputMaybe<Scalars['Int']>;
  accountID_lte?: InputMaybe<Scalars['Int']>;
  accountID_not?: InputMaybe<Scalars['Int']>;
  accountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  nonce?: InputMaybe<Scalars['Int']>;
  nonce_gt?: InputMaybe<Scalars['Int']>;
  nonce_gte?: InputMaybe<Scalars['Int']>;
  nonce_in?: InputMaybe<Array<Scalars['Int']>>;
  nonce_lt?: InputMaybe<Scalars['Int']>;
  nonce_lte?: InputMaybe<Scalars['Int']>;
  nonce_not?: InputMaybe<Scalars['Int']>;
  nonce_not_in?: InputMaybe<Array<Scalars['Int']>>;
  owner?: InputMaybe<Scalars['String']>;
  owner_contains?: InputMaybe<Scalars['String']>;
  owner_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_ends_with?: InputMaybe<Scalars['String']>;
  owner_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_gt?: InputMaybe<Scalars['String']>;
  owner_gte?: InputMaybe<Scalars['String']>;
  owner_in?: InputMaybe<Array<Scalars['String']>>;
  owner_lt?: InputMaybe<Scalars['String']>;
  owner_lte?: InputMaybe<Scalars['String']>;
  owner_not?: InputMaybe<Scalars['String']>;
  owner_not_contains?: InputMaybe<Scalars['String']>;
  owner_not_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_not_ends_with?: InputMaybe<Scalars['String']>;
  owner_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_not_in?: InputMaybe<Array<Scalars['String']>>;
  owner_not_starts_with?: InputMaybe<Scalars['String']>;
  owner_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  owner_starts_with?: InputMaybe<Scalars['String']>;
  owner_starts_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey?: InputMaybe<Scalars['String']>;
  publicKey_contains?: InputMaybe<Scalars['String']>;
  publicKey_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_gt?: InputMaybe<Scalars['String']>;
  publicKey_gte?: InputMaybe<Scalars['String']>;
  publicKey_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_lt?: InputMaybe<Scalars['String']>;
  publicKey_lte?: InputMaybe<Scalars['String']>;
  publicKey_not?: InputMaybe<Scalars['String']>;
  publicKey_not_contains?: InputMaybe<Scalars['String']>;
  publicKey_not_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_not_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
  updateType?: InputMaybe<Scalars['Int']>;
  updateType_gt?: InputMaybe<Scalars['Int']>;
  updateType_gte?: InputMaybe<Scalars['Int']>;
  updateType_in?: InputMaybe<Array<Scalars['Int']>>;
  updateType_lt?: InputMaybe<Scalars['Int']>;
  updateType_lte?: InputMaybe<Scalars['Int']>;
  updateType_not?: InputMaybe<Scalars['Int']>;
  updateType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  user?: InputMaybe<Scalars['String']>;
  user_?: InputMaybe<User_Filter>;
  user_contains?: InputMaybe<Scalars['String']>;
  user_contains_nocase?: InputMaybe<Scalars['String']>;
  user_ends_with?: InputMaybe<Scalars['String']>;
  user_ends_with_nocase?: InputMaybe<Scalars['String']>;
  user_gt?: InputMaybe<Scalars['String']>;
  user_gte?: InputMaybe<Scalars['String']>;
  user_in?: InputMaybe<Array<Scalars['String']>>;
  user_lt?: InputMaybe<Scalars['String']>;
  user_lte?: InputMaybe<Scalars['String']>;
  user_not?: InputMaybe<Scalars['String']>;
  user_not_contains?: InputMaybe<Scalars['String']>;
  user_not_contains_nocase?: InputMaybe<Scalars['String']>;
  user_not_ends_with?: InputMaybe<Scalars['String']>;
  user_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  user_not_in?: InputMaybe<Array<Scalars['String']>>;
  user_not_starts_with?: InputMaybe<Scalars['String']>;
  user_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  user_starts_with?: InputMaybe<Scalars['String']>;
  user_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum AccountUpdate_OrderBy {
  AccountId = 'accountID',
  Accounts = 'accounts',
  Block = 'block',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  Id = 'id',
  InternalId = 'internalID',
  Nonce = 'nonce',
  Owner = 'owner',
  PublicKey = 'publicKey',
  TokenBalances = 'tokenBalances',
  Typename = 'typename',
  UpdateType = 'updateType',
  User = 'user',
}

export type Account_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  balances_?: InputMaybe<AccountTokenBalance_Filter>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  transactions_?: InputMaybe<Transaction_Filter>;
};

export enum Account_OrderBy {
  Address = 'address',
  Balances = 'balances',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  Id = 'id',
  InternalId = 'internalID',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  Slots = 'slots',
  Transactions = 'transactions',
}

export type Add = Transaction & {
  __typename?: 'Add';
  /** Account entity that triggered the addition of liquidity from the pool */
  account: Account;
  /** [RAW L2 DATA] Account ID for the account that sent the tokens */
  accountFromID: Scalars['Int'];
  /** [RAW L2 DATA] Account ID for the account that received the tokens */
  accountToID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount transfered */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken: Token;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that sent the tokens */
  from: Scalars['String'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** Pool entity where the liquidity was added */
  pool: Pool;
  /** [RAW L2 DATA] StorageID */
  storageID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that received the tokens */
  to: Scalars['String'];
  /** [RAW L2 DATA] Token ID of the token transfered. Mainly used for NFT transfers */
  toTokenID: Scalars['Int'];
  /** Token entity with information about the token transfered */
  token: Token;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the token transfered */
  tokenID: Scalars['Int'];
  /** [RAW L2 DATA] Transfer type */
  type: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type AddAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type AddTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type Add_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountFromID?: InputMaybe<Scalars['Int']>;
  accountFromID_gt?: InputMaybe<Scalars['Int']>;
  accountFromID_gte?: InputMaybe<Scalars['Int']>;
  accountFromID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFromID_lt?: InputMaybe<Scalars['Int']>;
  accountFromID_lte?: InputMaybe<Scalars['Int']>;
  accountFromID_not?: InputMaybe<Scalars['Int']>;
  accountFromID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID?: InputMaybe<Scalars['Int']>;
  accountToID_gt?: InputMaybe<Scalars['Int']>;
  accountToID_gte?: InputMaybe<Scalars['Int']>;
  accountToID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID_lt?: InputMaybe<Scalars['Int']>;
  accountToID_lte?: InputMaybe<Scalars['Int']>;
  accountToID_not?: InputMaybe<Scalars['Int']>;
  accountToID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  pool?: InputMaybe<Scalars['String']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_ends_with?: InputMaybe<Scalars['String']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_gt?: InputMaybe<Scalars['String']>;
  pool_gte?: InputMaybe<Scalars['String']>;
  pool_in?: InputMaybe<Array<Scalars['String']>>;
  pool_lt?: InputMaybe<Scalars['String']>;
  pool_lte?: InputMaybe<Scalars['String']>;
  pool_not?: InputMaybe<Scalars['String']>;
  pool_not_contains?: InputMaybe<Scalars['String']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pool_starts_with?: InputMaybe<Scalars['String']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to?: InputMaybe<Scalars['String']>;
  toTokenID?: InputMaybe<Scalars['Int']>;
  toTokenID_gt?: InputMaybe<Scalars['Int']>;
  toTokenID_gte?: InputMaybe<Scalars['Int']>;
  toTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  toTokenID_lt?: InputMaybe<Scalars['Int']>;
  toTokenID_lte?: InputMaybe<Scalars['Int']>;
  toTokenID_not?: InputMaybe<Scalars['Int']>;
  toTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Add_OrderBy {
  Account = 'account',
  AccountFromId = 'accountFromID',
  AccountToId = 'accountToID',
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  From = 'from',
  Id = 'id',
  InternalId = 'internalID',
  Pool = 'pool',
  StorageId = 'storageID',
  To = 'to',
  ToTokenId = 'toTokenID',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Type = 'type',
  Typename = 'typename',
}

export type AmmUpdate = Transaction & {
  __typename?: 'AmmUpdate';
  /** [RAW L2 DATA] Account ID of the pool account updated */
  accountID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  balance: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  feeBips: Scalars['Int'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  nonce: Scalars['Int'];
  /** [RAW L2 DATA] Address of the pool account updated */
  owner: Scalars['String'];
  /** Pool account entity updated in this transaction */
  pool: Pool;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  tokenID: Scalars['Int'];
  tokenWeight: Scalars['BigInt'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type AmmUpdateAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type AmmUpdateTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type AmmUpdate_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountID?: InputMaybe<Scalars['Int']>;
  accountID_gt?: InputMaybe<Scalars['Int']>;
  accountID_gte?: InputMaybe<Scalars['Int']>;
  accountID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountID_lt?: InputMaybe<Scalars['Int']>;
  accountID_lte?: InputMaybe<Scalars['Int']>;
  accountID_not?: InputMaybe<Scalars['Int']>;
  accountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeBips?: InputMaybe<Scalars['Int']>;
  feeBips_gt?: InputMaybe<Scalars['Int']>;
  feeBips_gte?: InputMaybe<Scalars['Int']>;
  feeBips_in?: InputMaybe<Array<Scalars['Int']>>;
  feeBips_lt?: InputMaybe<Scalars['Int']>;
  feeBips_lte?: InputMaybe<Scalars['Int']>;
  feeBips_not?: InputMaybe<Scalars['Int']>;
  feeBips_not_in?: InputMaybe<Array<Scalars['Int']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  nonce?: InputMaybe<Scalars['Int']>;
  nonce_gt?: InputMaybe<Scalars['Int']>;
  nonce_gte?: InputMaybe<Scalars['Int']>;
  nonce_in?: InputMaybe<Array<Scalars['Int']>>;
  nonce_lt?: InputMaybe<Scalars['Int']>;
  nonce_lte?: InputMaybe<Scalars['Int']>;
  nonce_not?: InputMaybe<Scalars['Int']>;
  nonce_not_in?: InputMaybe<Array<Scalars['Int']>>;
  owner?: InputMaybe<Scalars['String']>;
  owner_contains?: InputMaybe<Scalars['String']>;
  owner_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_ends_with?: InputMaybe<Scalars['String']>;
  owner_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_gt?: InputMaybe<Scalars['String']>;
  owner_gte?: InputMaybe<Scalars['String']>;
  owner_in?: InputMaybe<Array<Scalars['String']>>;
  owner_lt?: InputMaybe<Scalars['String']>;
  owner_lte?: InputMaybe<Scalars['String']>;
  owner_not?: InputMaybe<Scalars['String']>;
  owner_not_contains?: InputMaybe<Scalars['String']>;
  owner_not_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_not_ends_with?: InputMaybe<Scalars['String']>;
  owner_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_not_in?: InputMaybe<Array<Scalars['String']>>;
  owner_not_starts_with?: InputMaybe<Scalars['String']>;
  owner_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  owner_starts_with?: InputMaybe<Scalars['String']>;
  owner_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pool?: InputMaybe<Scalars['String']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_ends_with?: InputMaybe<Scalars['String']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_gt?: InputMaybe<Scalars['String']>;
  pool_gte?: InputMaybe<Scalars['String']>;
  pool_in?: InputMaybe<Array<Scalars['String']>>;
  pool_lt?: InputMaybe<Scalars['String']>;
  pool_lte?: InputMaybe<Scalars['String']>;
  pool_not?: InputMaybe<Scalars['String']>;
  pool_not_contains?: InputMaybe<Scalars['String']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pool_starts_with?: InputMaybe<Scalars['String']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenWeight?: InputMaybe<Scalars['BigInt']>;
  tokenWeight_gt?: InputMaybe<Scalars['BigInt']>;
  tokenWeight_gte?: InputMaybe<Scalars['BigInt']>;
  tokenWeight_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenWeight_lt?: InputMaybe<Scalars['BigInt']>;
  tokenWeight_lte?: InputMaybe<Scalars['BigInt']>;
  tokenWeight_not?: InputMaybe<Scalars['BigInt']>;
  tokenWeight_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum AmmUpdate_OrderBy {
  AccountId = 'accountID',
  Accounts = 'accounts',
  Balance = 'balance',
  Block = 'block',
  Data = 'data',
  FeeBips = 'feeBips',
  Id = 'id',
  InternalId = 'internalID',
  Nonce = 'nonce',
  Owner = 'owner',
  Pool = 'pool',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  TokenWeight = 'tokenWeight',
  Typename = 'typename',
}

export type Block = {
  __typename?: 'Block';
  /** Total amount of AccountUpdate transactions processed on this block */
  accountUpdateCount: Scalars['BigInt'];
  /** Total amount of Add transactions processed on this block */
  addCount: Scalars['BigInt'];
  /** Total amount of AMMUpdate transactions processed on this block */
  ammUpdateCount: Scalars['BigInt'];
  /** Hash of the L1 Block where the L2 block was submitted */
  blockHash: Scalars['String'];
  /** L2 Block size. Represents the maximum amount of L2 transactions that it could handle. */
  blockSize: Scalars['Int'];
  /** L2 Block type represented as an Integer */
  blockType: Scalars['Int'];
  /** L2 Block version */
  blockVersion: Scalars['Int'];
  /** Raw data for the L2 block. Represented as a Hex String. */
  data: Scalars['String'];
  /** Total amount of Deposit transactions processed on this block */
  depositCount: Scalars['BigInt'];
  /** Amount of gas limit used */
  gasLimit: Scalars['BigInt'];
  /** Gas price for the L1 transaction */
  gasPrice: Scalars['BigInt'];
  /** L1 Block height where the L2 Block was submitted */
  height: Scalars['BigInt'];
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt so it can be used for sorting properly */
  internalID: Scalars['BigInt'];
  /** Total amount of NFT Data transactions processed on this block */
  nftDataCount: Scalars['BigInt'];
  /** Total amount of NFT Mint transactions processed on this block */
  nftMintCount: Scalars['BigInt'];
  numConditionalTransactions: Scalars['Int'];
  offchainData: Scalars['Bytes'];
  /** Account entity for the operator of this L2 Block */
  operatorAccount: Account;
  /** Account ID for the operator of this L2 Block */
  operatorAccountID: Scalars['Int'];
  /** Total amount of OrderbookTrade transactions processed on this block */
  orderbookTradeCount: Scalars['BigInt'];
  /** L2 proof data */
  proof: Array<Scalars['BigInt']>;
  /** Protocol fee applied to the 'maker' for L2 transactions within this block */
  protocolFeeMakerBips: Scalars['Int'];
  /** Protocol fee applied to the 'taker' for L2 transactions within this block */
  protocolFeeTakerBips: Scalars['Int'];
  /** Total amount of Remove transactions processed on this block */
  removeCount: Scalars['BigInt'];
  /** Total amount of SignatureVerification transactions processed on this block */
  signatureVerificationCount: Scalars['BigInt'];
  storeBlockInfoOnchain: Scalars['Boolean'];
  /** Total amount of Swap transactions processed on this block */
  swapCount: Scalars['BigInt'];
  /** Total amount of SwapNFT transactions processed on this block */
  swapNFTCount: Scalars['BigInt'];
  /** L1 Block timestamp when the L2 Block was submitted */
  timestamp: Scalars['BigInt'];
  /** Total amount of TradeNFT transactions processed on this block */
  tradeNFTCount: Scalars['BigInt'];
  /** Total amount of transactions processed on this block. Should coincide with the lenght of the transactions list */
  transactionCount: Scalars['BigInt'];
  /** List of L2 Transactions for this L2 Block */
  transactions: Array<Transaction>;
  /** Total amount of Transfer transactions processed on this block */
  transferCount: Scalars['BigInt'];
  /** Total amount of Transfer transactions processed on this block */
  transferNFTCount: Scalars['BigInt'];
  /** Transaction hash for the L1 Transaction where the L2 Block was submitted */
  txHash: Scalars['String'];
  /** Total amount of Withdrawal transactions processed on this block */
  withdrawalCount: Scalars['BigInt'];
  /** Total amount of WithdrawalNFT transactions processed on this block */
  withdrawalNFTCount: Scalars['BigInt'];
};

export type BlockTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type BlockChangedFilter = {
  number_gte: Scalars['Int'];
};

export type Block_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountUpdateCount?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountUpdateCount_lt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_lte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addCount?: InputMaybe<Scalars['BigInt']>;
  addCount_gt?: InputMaybe<Scalars['BigInt']>;
  addCount_gte?: InputMaybe<Scalars['BigInt']>;
  addCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addCount_lt?: InputMaybe<Scalars['BigInt']>;
  addCount_lte?: InputMaybe<Scalars['BigInt']>;
  addCount_not?: InputMaybe<Scalars['BigInt']>;
  addCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  ammUpdateCount?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_gt?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_gte?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  ammUpdateCount_lt?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_lte?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_not?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockHash?: InputMaybe<Scalars['String']>;
  blockHash_contains?: InputMaybe<Scalars['String']>;
  blockHash_contains_nocase?: InputMaybe<Scalars['String']>;
  blockHash_ends_with?: InputMaybe<Scalars['String']>;
  blockHash_ends_with_nocase?: InputMaybe<Scalars['String']>;
  blockHash_gt?: InputMaybe<Scalars['String']>;
  blockHash_gte?: InputMaybe<Scalars['String']>;
  blockHash_in?: InputMaybe<Array<Scalars['String']>>;
  blockHash_lt?: InputMaybe<Scalars['String']>;
  blockHash_lte?: InputMaybe<Scalars['String']>;
  blockHash_not?: InputMaybe<Scalars['String']>;
  blockHash_not_contains?: InputMaybe<Scalars['String']>;
  blockHash_not_contains_nocase?: InputMaybe<Scalars['String']>;
  blockHash_not_ends_with?: InputMaybe<Scalars['String']>;
  blockHash_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  blockHash_not_in?: InputMaybe<Array<Scalars['String']>>;
  blockHash_not_starts_with?: InputMaybe<Scalars['String']>;
  blockHash_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  blockHash_starts_with?: InputMaybe<Scalars['String']>;
  blockHash_starts_with_nocase?: InputMaybe<Scalars['String']>;
  blockSize?: InputMaybe<Scalars['Int']>;
  blockSize_gt?: InputMaybe<Scalars['Int']>;
  blockSize_gte?: InputMaybe<Scalars['Int']>;
  blockSize_in?: InputMaybe<Array<Scalars['Int']>>;
  blockSize_lt?: InputMaybe<Scalars['Int']>;
  blockSize_lte?: InputMaybe<Scalars['Int']>;
  blockSize_not?: InputMaybe<Scalars['Int']>;
  blockSize_not_in?: InputMaybe<Array<Scalars['Int']>>;
  blockType?: InputMaybe<Scalars['Int']>;
  blockType_gt?: InputMaybe<Scalars['Int']>;
  blockType_gte?: InputMaybe<Scalars['Int']>;
  blockType_in?: InputMaybe<Array<Scalars['Int']>>;
  blockType_lt?: InputMaybe<Scalars['Int']>;
  blockType_lte?: InputMaybe<Scalars['Int']>;
  blockType_not?: InputMaybe<Scalars['Int']>;
  blockType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  blockVersion?: InputMaybe<Scalars['Int']>;
  blockVersion_gt?: InputMaybe<Scalars['Int']>;
  blockVersion_gte?: InputMaybe<Scalars['Int']>;
  blockVersion_in?: InputMaybe<Array<Scalars['Int']>>;
  blockVersion_lt?: InputMaybe<Scalars['Int']>;
  blockVersion_lte?: InputMaybe<Scalars['Int']>;
  blockVersion_not?: InputMaybe<Scalars['Int']>;
  blockVersion_not_in?: InputMaybe<Array<Scalars['Int']>>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  depositCount?: InputMaybe<Scalars['BigInt']>;
  depositCount_gt?: InputMaybe<Scalars['BigInt']>;
  depositCount_gte?: InputMaybe<Scalars['BigInt']>;
  depositCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  depositCount_lt?: InputMaybe<Scalars['BigInt']>;
  depositCount_lte?: InputMaybe<Scalars['BigInt']>;
  depositCount_not?: InputMaybe<Scalars['BigInt']>;
  depositCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasLimit?: InputMaybe<Scalars['BigInt']>;
  gasLimit_gt?: InputMaybe<Scalars['BigInt']>;
  gasLimit_gte?: InputMaybe<Scalars['BigInt']>;
  gasLimit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasLimit_lt?: InputMaybe<Scalars['BigInt']>;
  gasLimit_lte?: InputMaybe<Scalars['BigInt']>;
  gasLimit_not?: InputMaybe<Scalars['BigInt']>;
  gasLimit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  height?: InputMaybe<Scalars['BigInt']>;
  height_gt?: InputMaybe<Scalars['BigInt']>;
  height_gte?: InputMaybe<Scalars['BigInt']>;
  height_in?: InputMaybe<Array<Scalars['BigInt']>>;
  height_lt?: InputMaybe<Scalars['BigInt']>;
  height_lte?: InputMaybe<Scalars['BigInt']>;
  height_not?: InputMaybe<Scalars['BigInt']>;
  height_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftDataCount?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_gt?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_gte?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftDataCount_lt?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_lte?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_not?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftMintCount?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_gt?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_gte?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftMintCount_lt?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_lte?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_not?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  numConditionalTransactions?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_gt?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_gte?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_in?: InputMaybe<Array<Scalars['Int']>>;
  numConditionalTransactions_lt?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_lte?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_not?: InputMaybe<Scalars['Int']>;
  numConditionalTransactions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  offchainData?: InputMaybe<Scalars['Bytes']>;
  offchainData_contains?: InputMaybe<Scalars['Bytes']>;
  offchainData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  offchainData_not?: InputMaybe<Scalars['Bytes']>;
  offchainData_not_contains?: InputMaybe<Scalars['Bytes']>;
  offchainData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operatorAccount?: InputMaybe<Scalars['String']>;
  operatorAccountID?: InputMaybe<Scalars['Int']>;
  operatorAccountID_gt?: InputMaybe<Scalars['Int']>;
  operatorAccountID_gte?: InputMaybe<Scalars['Int']>;
  operatorAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  operatorAccountID_lt?: InputMaybe<Scalars['Int']>;
  operatorAccountID_lte?: InputMaybe<Scalars['Int']>;
  operatorAccountID_not?: InputMaybe<Scalars['Int']>;
  operatorAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  operatorAccount_?: InputMaybe<Account_Filter>;
  operatorAccount_contains?: InputMaybe<Scalars['String']>;
  operatorAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_ends_with?: InputMaybe<Scalars['String']>;
  operatorAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_gt?: InputMaybe<Scalars['String']>;
  operatorAccount_gte?: InputMaybe<Scalars['String']>;
  operatorAccount_in?: InputMaybe<Array<Scalars['String']>>;
  operatorAccount_lt?: InputMaybe<Scalars['String']>;
  operatorAccount_lte?: InputMaybe<Scalars['String']>;
  operatorAccount_not?: InputMaybe<Scalars['String']>;
  operatorAccount_not_contains?: InputMaybe<Scalars['String']>;
  operatorAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  operatorAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  operatorAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  operatorAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  operatorAccount_starts_with?: InputMaybe<Scalars['String']>;
  operatorAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  orderbookTradeCount?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderbookTradeCount_lt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_lte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  proof?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_contains?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_contains_nocase?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_not?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_not_contains?: InputMaybe<Array<Scalars['BigInt']>>;
  proof_not_contains_nocase?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeMakerBips?: InputMaybe<Scalars['Int']>;
  protocolFeeMakerBips_gt?: InputMaybe<Scalars['Int']>;
  protocolFeeMakerBips_gte?: InputMaybe<Scalars['Int']>;
  protocolFeeMakerBips_in?: InputMaybe<Array<Scalars['Int']>>;
  protocolFeeMakerBips_lt?: InputMaybe<Scalars['Int']>;
  protocolFeeMakerBips_lte?: InputMaybe<Scalars['Int']>;
  protocolFeeMakerBips_not?: InputMaybe<Scalars['Int']>;
  protocolFeeMakerBips_not_in?: InputMaybe<Array<Scalars['Int']>>;
  protocolFeeTakerBips?: InputMaybe<Scalars['Int']>;
  protocolFeeTakerBips_gt?: InputMaybe<Scalars['Int']>;
  protocolFeeTakerBips_gte?: InputMaybe<Scalars['Int']>;
  protocolFeeTakerBips_in?: InputMaybe<Array<Scalars['Int']>>;
  protocolFeeTakerBips_lt?: InputMaybe<Scalars['Int']>;
  protocolFeeTakerBips_lte?: InputMaybe<Scalars['Int']>;
  protocolFeeTakerBips_not?: InputMaybe<Scalars['Int']>;
  protocolFeeTakerBips_not_in?: InputMaybe<Array<Scalars['Int']>>;
  removeCount?: InputMaybe<Scalars['BigInt']>;
  removeCount_gt?: InputMaybe<Scalars['BigInt']>;
  removeCount_gte?: InputMaybe<Scalars['BigInt']>;
  removeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  removeCount_lt?: InputMaybe<Scalars['BigInt']>;
  removeCount_lte?: InputMaybe<Scalars['BigInt']>;
  removeCount_not?: InputMaybe<Scalars['BigInt']>;
  removeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount_lt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_lte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  storeBlockInfoOnchain?: InputMaybe<Scalars['Boolean']>;
  storeBlockInfoOnchain_in?: InputMaybe<Array<Scalars['Boolean']>>;
  storeBlockInfoOnchain_not?: InputMaybe<Scalars['Boolean']>;
  storeBlockInfoOnchain_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  swapCount?: InputMaybe<Scalars['BigInt']>;
  swapCount_gt?: InputMaybe<Scalars['BigInt']>;
  swapCount_gte?: InputMaybe<Scalars['BigInt']>;
  swapCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapCount_lt?: InputMaybe<Scalars['BigInt']>;
  swapCount_lte?: InputMaybe<Scalars['BigInt']>;
  swapCount_not?: InputMaybe<Scalars['BigInt']>;
  swapCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapNFTCount?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradeNFTCount?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradeNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount_lt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_lte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactions_?: InputMaybe<Transaction_Filter>;
  transferCount?: InputMaybe<Scalars['BigInt']>;
  transferCount_gt?: InputMaybe<Scalars['BigInt']>;
  transferCount_gte?: InputMaybe<Scalars['BigInt']>;
  transferCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferCount_lt?: InputMaybe<Scalars['BigInt']>;
  transferCount_lte?: InputMaybe<Scalars['BigInt']>;
  transferCount_not?: InputMaybe<Scalars['BigInt']>;
  transferCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferNFTCount?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  txHash?: InputMaybe<Scalars['String']>;
  txHash_contains?: InputMaybe<Scalars['String']>;
  txHash_contains_nocase?: InputMaybe<Scalars['String']>;
  txHash_ends_with?: InputMaybe<Scalars['String']>;
  txHash_ends_with_nocase?: InputMaybe<Scalars['String']>;
  txHash_gt?: InputMaybe<Scalars['String']>;
  txHash_gte?: InputMaybe<Scalars['String']>;
  txHash_in?: InputMaybe<Array<Scalars['String']>>;
  txHash_lt?: InputMaybe<Scalars['String']>;
  txHash_lte?: InputMaybe<Scalars['String']>;
  txHash_not?: InputMaybe<Scalars['String']>;
  txHash_not_contains?: InputMaybe<Scalars['String']>;
  txHash_not_contains_nocase?: InputMaybe<Scalars['String']>;
  txHash_not_ends_with?: InputMaybe<Scalars['String']>;
  txHash_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  txHash_not_in?: InputMaybe<Array<Scalars['String']>>;
  txHash_not_starts_with?: InputMaybe<Scalars['String']>;
  txHash_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  txHash_starts_with?: InputMaybe<Scalars['String']>;
  txHash_starts_with_nocase?: InputMaybe<Scalars['String']>;
  withdrawalCount?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalCount_lt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_lte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalNFTCount?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export type Block_Height = {
  hash?: InputMaybe<Scalars['Bytes']>;
  number?: InputMaybe<Scalars['Int']>;
  number_gte?: InputMaybe<Scalars['Int']>;
};

export enum Block_OrderBy {
  AccountUpdateCount = 'accountUpdateCount',
  AddCount = 'addCount',
  AmmUpdateCount = 'ammUpdateCount',
  BlockHash = 'blockHash',
  BlockSize = 'blockSize',
  BlockType = 'blockType',
  BlockVersion = 'blockVersion',
  Data = 'data',
  DepositCount = 'depositCount',
  GasLimit = 'gasLimit',
  GasPrice = 'gasPrice',
  Height = 'height',
  Id = 'id',
  InternalId = 'internalID',
  NftDataCount = 'nftDataCount',
  NftMintCount = 'nftMintCount',
  NumConditionalTransactions = 'numConditionalTransactions',
  OffchainData = 'offchainData',
  OperatorAccount = 'operatorAccount',
  OperatorAccountId = 'operatorAccountID',
  OrderbookTradeCount = 'orderbookTradeCount',
  Proof = 'proof',
  ProtocolFeeMakerBips = 'protocolFeeMakerBips',
  ProtocolFeeTakerBips = 'protocolFeeTakerBips',
  RemoveCount = 'removeCount',
  SignatureVerificationCount = 'signatureVerificationCount',
  StoreBlockInfoOnchain = 'storeBlockInfoOnchain',
  SwapCount = 'swapCount',
  SwapNftCount = 'swapNFTCount',
  Timestamp = 'timestamp',
  TradeNftCount = 'tradeNFTCount',
  TransactionCount = 'transactionCount',
  Transactions = 'transactions',
  TransferCount = 'transferCount',
  TransferNftCount = 'transferNFTCount',
  TxHash = 'txHash',
  WithdrawalCount = 'withdrawalCount',
  WithdrawalNftCount = 'withdrawalNFTCount',
}

export type DataNft = Transaction &
  TransactionNft & {
    __typename?: 'DataNFT';
    accountID: Scalars['Int'];
    accounts?: Maybe<Array<Account>>;
    block: Block;
    creatorFeeBips: Scalars['Int'];
    data: Scalars['String'];
    id: Scalars['ID'];
    /** ID represented as a BigDecimal for sorting purposes */
    internalID: Scalars['BigDecimal'];
    minter?: Maybe<Scalars['String']>;
    nftID: Scalars['String'];
    nftType: Scalars['Int'];
    nfts: Array<NonFungibleToken>;
    slots: Array<AccountNftSlot>;
    tokenAddress?: Maybe<Scalars['String']>;
    tokenBalances?: Maybe<Array<AccountTokenBalance>>;
    tokenID: Scalars['Int'];
    type: Scalars['Int'];
    /** Explicit copy of __typename to make it usable when filtering */
    typename: TransactionType;
  };

export type DataNftAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type DataNftNftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type DataNftSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type DataNftTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type DataNft_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountID?: InputMaybe<Scalars['Int']>;
  accountID_gt?: InputMaybe<Scalars['Int']>;
  accountID_gte?: InputMaybe<Scalars['Int']>;
  accountID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountID_lt?: InputMaybe<Scalars['Int']>;
  accountID_lte?: InputMaybe<Scalars['Int']>;
  accountID_not?: InputMaybe<Scalars['Int']>;
  accountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  creatorFeeBips?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_gt?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_gte?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_in?: InputMaybe<Array<Scalars['Int']>>;
  creatorFeeBips_lt?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_lte?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_not?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_not_in?: InputMaybe<Array<Scalars['Int']>>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  minter?: InputMaybe<Scalars['String']>;
  minter_contains?: InputMaybe<Scalars['String']>;
  minter_contains_nocase?: InputMaybe<Scalars['String']>;
  minter_ends_with?: InputMaybe<Scalars['String']>;
  minter_ends_with_nocase?: InputMaybe<Scalars['String']>;
  minter_gt?: InputMaybe<Scalars['String']>;
  minter_gte?: InputMaybe<Scalars['String']>;
  minter_in?: InputMaybe<Array<Scalars['String']>>;
  minter_lt?: InputMaybe<Scalars['String']>;
  minter_lte?: InputMaybe<Scalars['String']>;
  minter_not?: InputMaybe<Scalars['String']>;
  minter_not_contains?: InputMaybe<Scalars['String']>;
  minter_not_contains_nocase?: InputMaybe<Scalars['String']>;
  minter_not_ends_with?: InputMaybe<Scalars['String']>;
  minter_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  minter_not_in?: InputMaybe<Array<Scalars['String']>>;
  minter_not_starts_with?: InputMaybe<Scalars['String']>;
  minter_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  minter_starts_with?: InputMaybe<Scalars['String']>;
  minter_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftID?: InputMaybe<Scalars['String']>;
  nftID_contains?: InputMaybe<Scalars['String']>;
  nftID_contains_nocase?: InputMaybe<Scalars['String']>;
  nftID_ends_with?: InputMaybe<Scalars['String']>;
  nftID_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_gt?: InputMaybe<Scalars['String']>;
  nftID_gte?: InputMaybe<Scalars['String']>;
  nftID_in?: InputMaybe<Array<Scalars['String']>>;
  nftID_lt?: InputMaybe<Scalars['String']>;
  nftID_lte?: InputMaybe<Scalars['String']>;
  nftID_not?: InputMaybe<Scalars['String']>;
  nftID_not_contains?: InputMaybe<Scalars['String']>;
  nftID_not_contains_nocase?: InputMaybe<Scalars['String']>;
  nftID_not_ends_with?: InputMaybe<Scalars['String']>;
  nftID_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_not_in?: InputMaybe<Array<Scalars['String']>>;
  nftID_not_starts_with?: InputMaybe<Scalars['String']>;
  nftID_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_starts_with?: InputMaybe<Scalars['String']>;
  nftID_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftType?: InputMaybe<Scalars['Int']>;
  nftType_gt?: InputMaybe<Scalars['Int']>;
  nftType_gte?: InputMaybe<Scalars['Int']>;
  nftType_in?: InputMaybe<Array<Scalars['Int']>>;
  nftType_lt?: InputMaybe<Scalars['Int']>;
  nftType_lte?: InputMaybe<Scalars['Int']>;
  nftType_not?: InputMaybe<Scalars['Int']>;
  nftType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  nfts?: InputMaybe<Array<Scalars['String']>>;
  nfts_?: InputMaybe<NonFungibleToken_Filter>;
  nfts_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  nfts_not?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots?: InputMaybe<Array<Scalars['String']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  slots_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots_not?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenAddress?: InputMaybe<Scalars['String']>;
  tokenAddress_contains?: InputMaybe<Scalars['String']>;
  tokenAddress_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_ends_with?: InputMaybe<Scalars['String']>;
  tokenAddress_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_gt?: InputMaybe<Scalars['String']>;
  tokenAddress_gte?: InputMaybe<Scalars['String']>;
  tokenAddress_in?: InputMaybe<Array<Scalars['String']>>;
  tokenAddress_lt?: InputMaybe<Scalars['String']>;
  tokenAddress_lte?: InputMaybe<Scalars['String']>;
  tokenAddress_not?: InputMaybe<Scalars['String']>;
  tokenAddress_not_contains?: InputMaybe<Scalars['String']>;
  tokenAddress_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenAddress_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenAddress_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenAddress_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_starts_with?: InputMaybe<Scalars['String']>;
  tokenAddress_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum DataNft_OrderBy {
  AccountId = 'accountID',
  Accounts = 'accounts',
  Block = 'block',
  CreatorFeeBips = 'creatorFeeBips',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  Minter = 'minter',
  NftId = 'nftID',
  NftType = 'nftType',
  Nfts = 'nfts',
  Slots = 'slots',
  TokenAddress = 'tokenAddress',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Type = 'type',
  Typename = 'typename',
}

export type Deposit = Transaction & {
  __typename?: 'Deposit';
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount deposited */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Address string of the account that deposited */
  to: Scalars['String'];
  /** Account entity that deposited the tokens */
  toAccount: Account;
  /** [RAW L2 DATA] Account ID for the account that deposited */
  toAccountID: Scalars['Int'];
  /** Token entity with information about the deposited token */
  token: Token;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the deposited token */
  tokenID: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type DepositAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type DepositTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type Deposit_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  to?: InputMaybe<Scalars['String']>;
  toAccount?: InputMaybe<Scalars['String']>;
  toAccountID?: InputMaybe<Scalars['Int']>;
  toAccountID_gt?: InputMaybe<Scalars['Int']>;
  toAccountID_gte?: InputMaybe<Scalars['Int']>;
  toAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  toAccountID_lt?: InputMaybe<Scalars['Int']>;
  toAccountID_lte?: InputMaybe<Scalars['Int']>;
  toAccountID_not?: InputMaybe<Scalars['Int']>;
  toAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  toAccount_?: InputMaybe<Account_Filter>;
  toAccount_contains?: InputMaybe<Scalars['String']>;
  toAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_gt?: InputMaybe<Scalars['String']>;
  toAccount_gte?: InputMaybe<Scalars['String']>;
  toAccount_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_lt?: InputMaybe<Scalars['String']>;
  toAccount_lte?: InputMaybe<Scalars['String']>;
  toAccount_not?: InputMaybe<Scalars['String']>;
  toAccount_not_contains?: InputMaybe<Scalars['String']>;
  toAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Deposit_OrderBy {
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  To = 'to',
  ToAccount = 'toAccount',
  ToAccountId = 'toAccountID',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Typename = 'typename',
}

export type Exchange = {
  __typename?: 'Exchange';
  /** Address of the exchange implementation */
  id: Scalars['ID'];
  /** Proxy link. Used to generate derived array of implementations. */
  proxy: Proxy;
  /** List of all tokens supported during the time this Exchange was the current implementation */
  tokens: Array<Token>;
};

export type ExchangeTokensArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Token_Filter>;
};

export type Exchange_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  proxy?: InputMaybe<Scalars['String']>;
  proxy_?: InputMaybe<Proxy_Filter>;
  proxy_contains?: InputMaybe<Scalars['String']>;
  proxy_contains_nocase?: InputMaybe<Scalars['String']>;
  proxy_ends_with?: InputMaybe<Scalars['String']>;
  proxy_ends_with_nocase?: InputMaybe<Scalars['String']>;
  proxy_gt?: InputMaybe<Scalars['String']>;
  proxy_gte?: InputMaybe<Scalars['String']>;
  proxy_in?: InputMaybe<Array<Scalars['String']>>;
  proxy_lt?: InputMaybe<Scalars['String']>;
  proxy_lte?: InputMaybe<Scalars['String']>;
  proxy_not?: InputMaybe<Scalars['String']>;
  proxy_not_contains?: InputMaybe<Scalars['String']>;
  proxy_not_contains_nocase?: InputMaybe<Scalars['String']>;
  proxy_not_ends_with?: InputMaybe<Scalars['String']>;
  proxy_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  proxy_not_in?: InputMaybe<Array<Scalars['String']>>;
  proxy_not_starts_with?: InputMaybe<Scalars['String']>;
  proxy_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  proxy_starts_with?: InputMaybe<Scalars['String']>;
  proxy_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokens_?: InputMaybe<Token_Filter>;
};

export enum Exchange_OrderBy {
  Id = 'id',
  Proxy = 'proxy',
  Tokens = 'tokens',
}

export type MintNft = Transaction &
  TransactionNft & {
    __typename?: 'MintNFT';
    accounts?: Maybe<Array<Account>>;
    amount: Scalars['BigInt'];
    block: Block;
    creatorFeeBips: Scalars['Int'];
    data: Scalars['String'];
    /** Data from the NFTData transactions that follow the mint */
    extraData?: Maybe<Scalars['String']>;
    fee: Scalars['BigInt'];
    /** Token entity with information about the token used to pay the operator fees */
    feeToken: Token;
    feeTokenID: Scalars['Int'];
    id: Scalars['ID'];
    /** ID represented as a BigDecimal for sorting purposes */
    internalID: Scalars['BigDecimal'];
    minter: Account;
    minterAccountID: Scalars['Int'];
    nft: NonFungibleToken;
    nftID: Scalars['String'];
    nftType: Scalars['Int'];
    nfts: Array<NonFungibleToken>;
    receiver: Account;
    receiverSlot: AccountNftSlot;
    slots: Array<AccountNftSlot>;
    storageID?: Maybe<Scalars['Int']>;
    to?: Maybe<Scalars['String']>;
    toAccountID?: Maybe<Scalars['Int']>;
    toTokenID: Scalars['Int'];
    tokenAccountID?: Maybe<Scalars['Int']>;
    tokenAddress: Scalars['String'];
    tokenBalances?: Maybe<Array<AccountTokenBalance>>;
    type: Scalars['Int'];
    /** Explicit copy of __typename to make it usable when filtering */
    typename: TransactionType;
  };

export type MintNftAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type MintNftNftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type MintNftSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type MintNftTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type MintNft_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  creatorFeeBips?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_gt?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_gte?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_in?: InputMaybe<Array<Scalars['Int']>>;
  creatorFeeBips_lt?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_lte?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_not?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_not_in?: InputMaybe<Array<Scalars['Int']>>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  extraData?: InputMaybe<Scalars['String']>;
  extraData_contains?: InputMaybe<Scalars['String']>;
  extraData_contains_nocase?: InputMaybe<Scalars['String']>;
  extraData_ends_with?: InputMaybe<Scalars['String']>;
  extraData_ends_with_nocase?: InputMaybe<Scalars['String']>;
  extraData_gt?: InputMaybe<Scalars['String']>;
  extraData_gte?: InputMaybe<Scalars['String']>;
  extraData_in?: InputMaybe<Array<Scalars['String']>>;
  extraData_lt?: InputMaybe<Scalars['String']>;
  extraData_lte?: InputMaybe<Scalars['String']>;
  extraData_not?: InputMaybe<Scalars['String']>;
  extraData_not_contains?: InputMaybe<Scalars['String']>;
  extraData_not_contains_nocase?: InputMaybe<Scalars['String']>;
  extraData_not_ends_with?: InputMaybe<Scalars['String']>;
  extraData_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  extraData_not_in?: InputMaybe<Array<Scalars['String']>>;
  extraData_not_starts_with?: InputMaybe<Scalars['String']>;
  extraData_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  extraData_starts_with?: InputMaybe<Scalars['String']>;
  extraData_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  minter?: InputMaybe<Scalars['String']>;
  minterAccountID?: InputMaybe<Scalars['Int']>;
  minterAccountID_gt?: InputMaybe<Scalars['Int']>;
  minterAccountID_gte?: InputMaybe<Scalars['Int']>;
  minterAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  minterAccountID_lt?: InputMaybe<Scalars['Int']>;
  minterAccountID_lte?: InputMaybe<Scalars['Int']>;
  minterAccountID_not?: InputMaybe<Scalars['Int']>;
  minterAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  minter_?: InputMaybe<Account_Filter>;
  minter_contains?: InputMaybe<Scalars['String']>;
  minter_contains_nocase?: InputMaybe<Scalars['String']>;
  minter_ends_with?: InputMaybe<Scalars['String']>;
  minter_ends_with_nocase?: InputMaybe<Scalars['String']>;
  minter_gt?: InputMaybe<Scalars['String']>;
  minter_gte?: InputMaybe<Scalars['String']>;
  minter_in?: InputMaybe<Array<Scalars['String']>>;
  minter_lt?: InputMaybe<Scalars['String']>;
  minter_lte?: InputMaybe<Scalars['String']>;
  minter_not?: InputMaybe<Scalars['String']>;
  minter_not_contains?: InputMaybe<Scalars['String']>;
  minter_not_contains_nocase?: InputMaybe<Scalars['String']>;
  minter_not_ends_with?: InputMaybe<Scalars['String']>;
  minter_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  minter_not_in?: InputMaybe<Array<Scalars['String']>>;
  minter_not_starts_with?: InputMaybe<Scalars['String']>;
  minter_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  minter_starts_with?: InputMaybe<Scalars['String']>;
  minter_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nft?: InputMaybe<Scalars['String']>;
  nftID?: InputMaybe<Scalars['String']>;
  nftID_contains?: InputMaybe<Scalars['String']>;
  nftID_contains_nocase?: InputMaybe<Scalars['String']>;
  nftID_ends_with?: InputMaybe<Scalars['String']>;
  nftID_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_gt?: InputMaybe<Scalars['String']>;
  nftID_gte?: InputMaybe<Scalars['String']>;
  nftID_in?: InputMaybe<Array<Scalars['String']>>;
  nftID_lt?: InputMaybe<Scalars['String']>;
  nftID_lte?: InputMaybe<Scalars['String']>;
  nftID_not?: InputMaybe<Scalars['String']>;
  nftID_not_contains?: InputMaybe<Scalars['String']>;
  nftID_not_contains_nocase?: InputMaybe<Scalars['String']>;
  nftID_not_ends_with?: InputMaybe<Scalars['String']>;
  nftID_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_not_in?: InputMaybe<Array<Scalars['String']>>;
  nftID_not_starts_with?: InputMaybe<Scalars['String']>;
  nftID_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_starts_with?: InputMaybe<Scalars['String']>;
  nftID_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftType?: InputMaybe<Scalars['Int']>;
  nftType_gt?: InputMaybe<Scalars['Int']>;
  nftType_gte?: InputMaybe<Scalars['Int']>;
  nftType_in?: InputMaybe<Array<Scalars['Int']>>;
  nftType_lt?: InputMaybe<Scalars['Int']>;
  nftType_lte?: InputMaybe<Scalars['Int']>;
  nftType_not?: InputMaybe<Scalars['Int']>;
  nftType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  nft_?: InputMaybe<NonFungibleToken_Filter>;
  nft_contains?: InputMaybe<Scalars['String']>;
  nft_contains_nocase?: InputMaybe<Scalars['String']>;
  nft_ends_with?: InputMaybe<Scalars['String']>;
  nft_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nft_gt?: InputMaybe<Scalars['String']>;
  nft_gte?: InputMaybe<Scalars['String']>;
  nft_in?: InputMaybe<Array<Scalars['String']>>;
  nft_lt?: InputMaybe<Scalars['String']>;
  nft_lte?: InputMaybe<Scalars['String']>;
  nft_not?: InputMaybe<Scalars['String']>;
  nft_not_contains?: InputMaybe<Scalars['String']>;
  nft_not_contains_nocase?: InputMaybe<Scalars['String']>;
  nft_not_ends_with?: InputMaybe<Scalars['String']>;
  nft_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nft_not_in?: InputMaybe<Array<Scalars['String']>>;
  nft_not_starts_with?: InputMaybe<Scalars['String']>;
  nft_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nft_starts_with?: InputMaybe<Scalars['String']>;
  nft_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nfts?: InputMaybe<Array<Scalars['String']>>;
  nfts_?: InputMaybe<NonFungibleToken_Filter>;
  nfts_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  nfts_not?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  receiver?: InputMaybe<Scalars['String']>;
  receiverSlot?: InputMaybe<Scalars['String']>;
  receiverSlot_?: InputMaybe<AccountNftSlot_Filter>;
  receiverSlot_contains?: InputMaybe<Scalars['String']>;
  receiverSlot_contains_nocase?: InputMaybe<Scalars['String']>;
  receiverSlot_ends_with?: InputMaybe<Scalars['String']>;
  receiverSlot_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiverSlot_gt?: InputMaybe<Scalars['String']>;
  receiverSlot_gte?: InputMaybe<Scalars['String']>;
  receiverSlot_in?: InputMaybe<Array<Scalars['String']>>;
  receiverSlot_lt?: InputMaybe<Scalars['String']>;
  receiverSlot_lte?: InputMaybe<Scalars['String']>;
  receiverSlot_not?: InputMaybe<Scalars['String']>;
  receiverSlot_not_contains?: InputMaybe<Scalars['String']>;
  receiverSlot_not_contains_nocase?: InputMaybe<Scalars['String']>;
  receiverSlot_not_ends_with?: InputMaybe<Scalars['String']>;
  receiverSlot_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiverSlot_not_in?: InputMaybe<Array<Scalars['String']>>;
  receiverSlot_not_starts_with?: InputMaybe<Scalars['String']>;
  receiverSlot_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  receiverSlot_starts_with?: InputMaybe<Scalars['String']>;
  receiverSlot_starts_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_?: InputMaybe<Account_Filter>;
  receiver_contains?: InputMaybe<Scalars['String']>;
  receiver_contains_nocase?: InputMaybe<Scalars['String']>;
  receiver_ends_with?: InputMaybe<Scalars['String']>;
  receiver_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_gt?: InputMaybe<Scalars['String']>;
  receiver_gte?: InputMaybe<Scalars['String']>;
  receiver_in?: InputMaybe<Array<Scalars['String']>>;
  receiver_lt?: InputMaybe<Scalars['String']>;
  receiver_lte?: InputMaybe<Scalars['String']>;
  receiver_not?: InputMaybe<Scalars['String']>;
  receiver_not_contains?: InputMaybe<Scalars['String']>;
  receiver_not_contains_nocase?: InputMaybe<Scalars['String']>;
  receiver_not_ends_with?: InputMaybe<Scalars['String']>;
  receiver_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_not_in?: InputMaybe<Array<Scalars['String']>>;
  receiver_not_starts_with?: InputMaybe<Scalars['String']>;
  receiver_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_starts_with?: InputMaybe<Scalars['String']>;
  receiver_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slots?: InputMaybe<Array<Scalars['String']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  slots_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots_not?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to?: InputMaybe<Scalars['String']>;
  toAccountID?: InputMaybe<Scalars['Int']>;
  toAccountID_gt?: InputMaybe<Scalars['Int']>;
  toAccountID_gte?: InputMaybe<Scalars['Int']>;
  toAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  toAccountID_lt?: InputMaybe<Scalars['Int']>;
  toAccountID_lte?: InputMaybe<Scalars['Int']>;
  toAccountID_not?: InputMaybe<Scalars['Int']>;
  toAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  toTokenID?: InputMaybe<Scalars['Int']>;
  toTokenID_gt?: InputMaybe<Scalars['Int']>;
  toTokenID_gte?: InputMaybe<Scalars['Int']>;
  toTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  toTokenID_lt?: InputMaybe<Scalars['Int']>;
  toTokenID_lte?: InputMaybe<Scalars['Int']>;
  toTokenID_not?: InputMaybe<Scalars['Int']>;
  toTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenAccountID?: InputMaybe<Scalars['Int']>;
  tokenAccountID_gt?: InputMaybe<Scalars['Int']>;
  tokenAccountID_gte?: InputMaybe<Scalars['Int']>;
  tokenAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenAccountID_lt?: InputMaybe<Scalars['Int']>;
  tokenAccountID_lte?: InputMaybe<Scalars['Int']>;
  tokenAccountID_not?: InputMaybe<Scalars['Int']>;
  tokenAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenAddress?: InputMaybe<Scalars['String']>;
  tokenAddress_contains?: InputMaybe<Scalars['String']>;
  tokenAddress_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_ends_with?: InputMaybe<Scalars['String']>;
  tokenAddress_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_gt?: InputMaybe<Scalars['String']>;
  tokenAddress_gte?: InputMaybe<Scalars['String']>;
  tokenAddress_in?: InputMaybe<Array<Scalars['String']>>;
  tokenAddress_lt?: InputMaybe<Scalars['String']>;
  tokenAddress_lte?: InputMaybe<Scalars['String']>;
  tokenAddress_not?: InputMaybe<Scalars['String']>;
  tokenAddress_not_contains?: InputMaybe<Scalars['String']>;
  tokenAddress_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenAddress_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenAddress_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenAddress_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenAddress_starts_with?: InputMaybe<Scalars['String']>;
  tokenAddress_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum MintNft_OrderBy {
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  CreatorFeeBips = 'creatorFeeBips',
  Data = 'data',
  ExtraData = 'extraData',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  Id = 'id',
  InternalId = 'internalID',
  Minter = 'minter',
  MinterAccountId = 'minterAccountID',
  Nft = 'nft',
  NftId = 'nftID',
  NftType = 'nftType',
  Nfts = 'nfts',
  Receiver = 'receiver',
  ReceiverSlot = 'receiverSlot',
  Slots = 'slots',
  StorageId = 'storageID',
  To = 'to',
  ToAccountId = 'toAccountID',
  ToTokenId = 'toTokenID',
  TokenAccountId = 'tokenAccountID',
  TokenAddress = 'tokenAddress',
  TokenBalances = 'tokenBalances',
  Type = 'type',
  Typename = 'typename',
}

export type NonFungibleToken = {
  __typename?: 'NonFungibleToken';
  creatorFeeBips: Scalars['Int'];
  /** ID is the Poseidon hash reported by L2 */
  id: Scalars['ID'];
  /** L2 transaction internalID where the NFT was minted. Useful for sorting and filtering purposes */
  mintedAt: Scalars['BigDecimal'];
  /** L2 transaction where the NFT was minted */
  mintedAtTransaction: MintNft;
  minter: Account;
  nftID: Scalars['String'];
  nftType: Scalars['Int'];
  /** List of all the AccountNFTSlot where this NFT is currently active. */
  slots: Array<AccountNftSlot>;
  token: Scalars['String'];
  /** List of all the transactions that this particular NFT was a part of */
  transactions: Array<TransactionNft>;
};

export type NonFungibleTokenSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type NonFungibleTokenTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TransactionNft_Filter>;
};

export type NonFungibleToken_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  creatorFeeBips?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_gt?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_gte?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_in?: InputMaybe<Array<Scalars['Int']>>;
  creatorFeeBips_lt?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_lte?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_not?: InputMaybe<Scalars['Int']>;
  creatorFeeBips_not_in?: InputMaybe<Array<Scalars['Int']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  mintedAt?: InputMaybe<Scalars['BigDecimal']>;
  mintedAtTransaction?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_?: InputMaybe<MintNft_Filter>;
  mintedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  mintedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_not?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  mintedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  mintedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  mintedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  mintedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  mintedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  mintedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  mintedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  mintedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  mintedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  minter?: InputMaybe<Scalars['String']>;
  minter_?: InputMaybe<Account_Filter>;
  minter_contains?: InputMaybe<Scalars['String']>;
  minter_contains_nocase?: InputMaybe<Scalars['String']>;
  minter_ends_with?: InputMaybe<Scalars['String']>;
  minter_ends_with_nocase?: InputMaybe<Scalars['String']>;
  minter_gt?: InputMaybe<Scalars['String']>;
  minter_gte?: InputMaybe<Scalars['String']>;
  minter_in?: InputMaybe<Array<Scalars['String']>>;
  minter_lt?: InputMaybe<Scalars['String']>;
  minter_lte?: InputMaybe<Scalars['String']>;
  minter_not?: InputMaybe<Scalars['String']>;
  minter_not_contains?: InputMaybe<Scalars['String']>;
  minter_not_contains_nocase?: InputMaybe<Scalars['String']>;
  minter_not_ends_with?: InputMaybe<Scalars['String']>;
  minter_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  minter_not_in?: InputMaybe<Array<Scalars['String']>>;
  minter_not_starts_with?: InputMaybe<Scalars['String']>;
  minter_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  minter_starts_with?: InputMaybe<Scalars['String']>;
  minter_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftID?: InputMaybe<Scalars['String']>;
  nftID_contains?: InputMaybe<Scalars['String']>;
  nftID_contains_nocase?: InputMaybe<Scalars['String']>;
  nftID_ends_with?: InputMaybe<Scalars['String']>;
  nftID_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_gt?: InputMaybe<Scalars['String']>;
  nftID_gte?: InputMaybe<Scalars['String']>;
  nftID_in?: InputMaybe<Array<Scalars['String']>>;
  nftID_lt?: InputMaybe<Scalars['String']>;
  nftID_lte?: InputMaybe<Scalars['String']>;
  nftID_not?: InputMaybe<Scalars['String']>;
  nftID_not_contains?: InputMaybe<Scalars['String']>;
  nftID_not_contains_nocase?: InputMaybe<Scalars['String']>;
  nftID_not_ends_with?: InputMaybe<Scalars['String']>;
  nftID_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_not_in?: InputMaybe<Array<Scalars['String']>>;
  nftID_not_starts_with?: InputMaybe<Scalars['String']>;
  nftID_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftID_starts_with?: InputMaybe<Scalars['String']>;
  nftID_starts_with_nocase?: InputMaybe<Scalars['String']>;
  nftType?: InputMaybe<Scalars['Int']>;
  nftType_gt?: InputMaybe<Scalars['Int']>;
  nftType_gte?: InputMaybe<Scalars['Int']>;
  nftType_in?: InputMaybe<Array<Scalars['Int']>>;
  nftType_lt?: InputMaybe<Scalars['Int']>;
  nftType_lte?: InputMaybe<Scalars['Int']>;
  nftType_not?: InputMaybe<Scalars['Int']>;
  nftType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  token?: InputMaybe<Scalars['String']>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  transactions_?: InputMaybe<TransactionNft_Filter>;
};

export enum NonFungibleToken_OrderBy {
  CreatorFeeBips = 'creatorFeeBips',
  Id = 'id',
  MintedAt = 'mintedAt',
  MintedAtTransaction = 'mintedAtTransaction',
  Minter = 'minter',
  NftId = 'nftID',
  NftType = 'nftType',
  Slots = 'slots',
  Token = 'token',
  Transactions = 'transactions',
}

/** Defines the order direction, either ascending or descending */
export enum OrderDirection {
  Asc = 'asc',
  Desc = 'desc',
}

export type OrderbookTrade = Transaction & {
  __typename?: 'OrderbookTrade';
  /** Account entity A */
  accountA: Account;
  /** Account entity B */
  accountB: Account;
  /** [RAW L2 DATA] Account ID of account A */
  accountIdA: Scalars['Int'];
  /** [RAW L2 DATA] Account ID of account B */
  accountIdB: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Float encoded value for fillSA represented as an Int */
  fFillSA: Scalars['Int'];
  /** [RAW L2 DATA] Float encoded value for fillSB represented as an Int */
  fFillSB: Scalars['Int'];
  /** [RAW L2 DATA] Fee paid by Account A with Token B */
  feeA: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee paid by Account B with token A */
  feeB: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee bips for order A */
  feeBipsA: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee bips for order B */
  feeBipsB: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data A */
  feeBipsHiA: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data B */
  feeBipsHiB: Scalars['BigInt'];
  /** [RAW L2 DATA] Is fill amount for buy or sell for order A */
  fillAmountBorSA: Scalars['Boolean'];
  /** [RAW L2 DATA] Is fill amount for buy or sell for order B */
  fillAmountBorSB: Scalars['Boolean'];
  /** [RAW L2 DATA] Amount of token B bought by Account A */
  fillBA: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token A bought by Account B */
  fillBB: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token A sold by Account A */
  fillSA: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token B sold by Account B */
  fillSB: Scalars['BigInt'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Limit mask value for order A */
  limitMaskA: Scalars['BigInt'];
  /** [RAW L2 DATA] Limit mask value for order B */
  limitMaskB: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data A */
  orderDataA: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data B */
  orderDataB: Scalars['BigInt'];
  /** Standardized Pair entity for this trade */
  pair: Pair;
  /** [RAW L2 DATA] Protocol fees paid by Account A */
  protocolFeeA: Scalars['BigInt'];
  /** [RAW L2 DATA] Protocol fees paid by Account B */
  protocolFeeB: Scalars['BigInt'];
  /** [RAW L2 DATA] StorageID for account A */
  storageIdA: Scalars['Int'];
  /** [RAW L2 DATA] StorageID for account B */
  storageIdB: Scalars['Int'];
  /** Token A. Supplied by Account A */
  tokenA: Token;
  /** Price for 1 unit of token A for this trade. Denominated in token B */
  tokenAPrice: Scalars['BigInt'];
  /** Token B. Supplied by Account B */
  tokenB: Token;
  /** Price for 1 unit of token B for this trade. Denominated in token A */
  tokenBPrice: Scalars['BigInt'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of token bought by account A. Should coincide with tokenIDBS */
  tokenIDAB: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token sold by account A */
  tokenIDAS: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token bought by account B. Should coincide with tokenIDAS */
  tokenIDBB: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token sold by account B */
  tokenIDBS: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type OrderbookTradeAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type OrderbookTradeTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type OrderbookTrade_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountA?: InputMaybe<Scalars['String']>;
  accountA_?: InputMaybe<Account_Filter>;
  accountA_contains?: InputMaybe<Scalars['String']>;
  accountA_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_ends_with?: InputMaybe<Scalars['String']>;
  accountA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_gt?: InputMaybe<Scalars['String']>;
  accountA_gte?: InputMaybe<Scalars['String']>;
  accountA_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_lt?: InputMaybe<Scalars['String']>;
  accountA_lte?: InputMaybe<Scalars['String']>;
  accountA_not?: InputMaybe<Scalars['String']>;
  accountA_not_contains?: InputMaybe<Scalars['String']>;
  accountA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_not_starts_with?: InputMaybe<Scalars['String']>;
  accountA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_starts_with?: InputMaybe<Scalars['String']>;
  accountA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB?: InputMaybe<Scalars['String']>;
  accountB_?: InputMaybe<Account_Filter>;
  accountB_contains?: InputMaybe<Scalars['String']>;
  accountB_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_ends_with?: InputMaybe<Scalars['String']>;
  accountB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_gt?: InputMaybe<Scalars['String']>;
  accountB_gte?: InputMaybe<Scalars['String']>;
  accountB_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_lt?: InputMaybe<Scalars['String']>;
  accountB_lte?: InputMaybe<Scalars['String']>;
  accountB_not?: InputMaybe<Scalars['String']>;
  accountB_not_contains?: InputMaybe<Scalars['String']>;
  accountB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_not_starts_with?: InputMaybe<Scalars['String']>;
  accountB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_starts_with?: InputMaybe<Scalars['String']>;
  accountB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountIdA?: InputMaybe<Scalars['Int']>;
  accountIdA_gt?: InputMaybe<Scalars['Int']>;
  accountIdA_gte?: InputMaybe<Scalars['Int']>;
  accountIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdA_lt?: InputMaybe<Scalars['Int']>;
  accountIdA_lte?: InputMaybe<Scalars['Int']>;
  accountIdA_not?: InputMaybe<Scalars['Int']>;
  accountIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB?: InputMaybe<Scalars['Int']>;
  accountIdB_gt?: InputMaybe<Scalars['Int']>;
  accountIdB_gte?: InputMaybe<Scalars['Int']>;
  accountIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB_lt?: InputMaybe<Scalars['Int']>;
  accountIdB_lte?: InputMaybe<Scalars['Int']>;
  accountIdB_not?: InputMaybe<Scalars['Int']>;
  accountIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fFillSA?: InputMaybe<Scalars['Int']>;
  fFillSA_gt?: InputMaybe<Scalars['Int']>;
  fFillSA_gte?: InputMaybe<Scalars['Int']>;
  fFillSA_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSA_lt?: InputMaybe<Scalars['Int']>;
  fFillSA_lte?: InputMaybe<Scalars['Int']>;
  fFillSA_not?: InputMaybe<Scalars['Int']>;
  fFillSA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB?: InputMaybe<Scalars['Int']>;
  fFillSB_gt?: InputMaybe<Scalars['Int']>;
  fFillSB_gte?: InputMaybe<Scalars['Int']>;
  fFillSB_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB_lt?: InputMaybe<Scalars['Int']>;
  fFillSB_lte?: InputMaybe<Scalars['Int']>;
  fFillSB_not?: InputMaybe<Scalars['Int']>;
  fFillSB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeA?: InputMaybe<Scalars['BigInt']>;
  feeA_gt?: InputMaybe<Scalars['BigInt']>;
  feeA_gte?: InputMaybe<Scalars['BigInt']>;
  feeA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeA_lt?: InputMaybe<Scalars['BigInt']>;
  feeA_lte?: InputMaybe<Scalars['BigInt']>;
  feeA_not?: InputMaybe<Scalars['BigInt']>;
  feeA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeB?: InputMaybe<Scalars['BigInt']>;
  feeB_gt?: InputMaybe<Scalars['BigInt']>;
  feeB_gte?: InputMaybe<Scalars['BigInt']>;
  feeB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeB_lt?: InputMaybe<Scalars['BigInt']>;
  feeB_lte?: InputMaybe<Scalars['BigInt']>;
  feeB_not?: InputMaybe<Scalars['BigInt']>;
  feeB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillAmountBorSA?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSA_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillBA?: InputMaybe<Scalars['BigInt']>;
  fillBA_gt?: InputMaybe<Scalars['BigInt']>;
  fillBA_gte?: InputMaybe<Scalars['BigInt']>;
  fillBA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBA_lt?: InputMaybe<Scalars['BigInt']>;
  fillBA_lte?: InputMaybe<Scalars['BigInt']>;
  fillBA_not?: InputMaybe<Scalars['BigInt']>;
  fillBA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB?: InputMaybe<Scalars['BigInt']>;
  fillBB_gt?: InputMaybe<Scalars['BigInt']>;
  fillBB_gte?: InputMaybe<Scalars['BigInt']>;
  fillBB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB_lt?: InputMaybe<Scalars['BigInt']>;
  fillBB_lte?: InputMaybe<Scalars['BigInt']>;
  fillBB_not?: InputMaybe<Scalars['BigInt']>;
  fillBB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA?: InputMaybe<Scalars['BigInt']>;
  fillSA_gt?: InputMaybe<Scalars['BigInt']>;
  fillSA_gte?: InputMaybe<Scalars['BigInt']>;
  fillSA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA_lt?: InputMaybe<Scalars['BigInt']>;
  fillSA_lte?: InputMaybe<Scalars['BigInt']>;
  fillSA_not?: InputMaybe<Scalars['BigInt']>;
  fillSA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB?: InputMaybe<Scalars['BigInt']>;
  fillSB_gt?: InputMaybe<Scalars['BigInt']>;
  fillSB_gte?: InputMaybe<Scalars['BigInt']>;
  fillSB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB_lt?: InputMaybe<Scalars['BigInt']>;
  fillSB_lte?: InputMaybe<Scalars['BigInt']>;
  fillSB_not?: InputMaybe<Scalars['BigInt']>;
  fillSB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  limitMaskA?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskA_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataA?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataA_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  pair?: InputMaybe<Scalars['String']>;
  pair_?: InputMaybe<Pair_Filter>;
  pair_contains?: InputMaybe<Scalars['String']>;
  pair_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_ends_with?: InputMaybe<Scalars['String']>;
  pair_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_gt?: InputMaybe<Scalars['String']>;
  pair_gte?: InputMaybe<Scalars['String']>;
  pair_in?: InputMaybe<Array<Scalars['String']>>;
  pair_lt?: InputMaybe<Scalars['String']>;
  pair_lte?: InputMaybe<Scalars['String']>;
  pair_not?: InputMaybe<Scalars['String']>;
  pair_not_contains?: InputMaybe<Scalars['String']>;
  pair_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_not_ends_with?: InputMaybe<Scalars['String']>;
  pair_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_not_in?: InputMaybe<Array<Scalars['String']>>;
  pair_not_starts_with?: InputMaybe<Scalars['String']>;
  pair_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pair_starts_with?: InputMaybe<Scalars['String']>;
  pair_starts_with_nocase?: InputMaybe<Scalars['String']>;
  protocolFeeA?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeA_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeB?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeB_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  storageIdA?: InputMaybe<Scalars['Int']>;
  storageIdA_gt?: InputMaybe<Scalars['Int']>;
  storageIdA_gte?: InputMaybe<Scalars['Int']>;
  storageIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdA_lt?: InputMaybe<Scalars['Int']>;
  storageIdA_lte?: InputMaybe<Scalars['Int']>;
  storageIdA_not?: InputMaybe<Scalars['Int']>;
  storageIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB?: InputMaybe<Scalars['Int']>;
  storageIdB_gt?: InputMaybe<Scalars['Int']>;
  storageIdB_gte?: InputMaybe<Scalars['Int']>;
  storageIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB_lt?: InputMaybe<Scalars['Int']>;
  storageIdB_lte?: InputMaybe<Scalars['Int']>;
  storageIdB_not?: InputMaybe<Scalars['Int']>;
  storageIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenA?: InputMaybe<Scalars['String']>;
  tokenAPrice?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_gt?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_gte?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenAPrice_lt?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_lte?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_not?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenA_?: InputMaybe<Token_Filter>;
  tokenA_contains?: InputMaybe<Scalars['String']>;
  tokenA_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_gt?: InputMaybe<Scalars['String']>;
  tokenA_gte?: InputMaybe<Scalars['String']>;
  tokenA_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_lt?: InputMaybe<Scalars['String']>;
  tokenA_lte?: InputMaybe<Scalars['String']>;
  tokenA_not?: InputMaybe<Scalars['String']>;
  tokenA_not_contains?: InputMaybe<Scalars['String']>;
  tokenA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB?: InputMaybe<Scalars['String']>;
  tokenBPrice?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_gt?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_gte?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenBPrice_lt?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_lte?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_not?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenB_?: InputMaybe<Token_Filter>;
  tokenB_contains?: InputMaybe<Scalars['String']>;
  tokenB_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_gt?: InputMaybe<Scalars['String']>;
  tokenB_gte?: InputMaybe<Scalars['String']>;
  tokenB_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_lt?: InputMaybe<Scalars['String']>;
  tokenB_lte?: InputMaybe<Scalars['String']>;
  tokenB_not?: InputMaybe<Scalars['String']>;
  tokenB_not_contains?: InputMaybe<Scalars['String']>;
  tokenB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenIDAB?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum OrderbookTrade_OrderBy {
  AccountA = 'accountA',
  AccountB = 'accountB',
  AccountIdA = 'accountIdA',
  AccountIdB = 'accountIdB',
  Accounts = 'accounts',
  Block = 'block',
  Data = 'data',
  FFillSa = 'fFillSA',
  FFillSb = 'fFillSB',
  FeeA = 'feeA',
  FeeB = 'feeB',
  FeeBipsA = 'feeBipsA',
  FeeBipsB = 'feeBipsB',
  FeeBipsHiA = 'feeBipsHiA',
  FeeBipsHiB = 'feeBipsHiB',
  FillAmountBorSa = 'fillAmountBorSA',
  FillAmountBorSb = 'fillAmountBorSB',
  FillBa = 'fillBA',
  FillBb = 'fillBB',
  FillSa = 'fillSA',
  FillSb = 'fillSB',
  Id = 'id',
  InternalId = 'internalID',
  LimitMaskA = 'limitMaskA',
  LimitMaskB = 'limitMaskB',
  OrderDataA = 'orderDataA',
  OrderDataB = 'orderDataB',
  Pair = 'pair',
  ProtocolFeeA = 'protocolFeeA',
  ProtocolFeeB = 'protocolFeeB',
  StorageIdA = 'storageIdA',
  StorageIdB = 'storageIdB',
  TokenA = 'tokenA',
  TokenAPrice = 'tokenAPrice',
  TokenB = 'tokenB',
  TokenBPrice = 'tokenBPrice',
  TokenBalances = 'tokenBalances',
  TokenIdab = 'tokenIDAB',
  TokenIdas = 'tokenIDAS',
  TokenIdbb = 'tokenIDBB',
  TokenIdbs = 'tokenIDBS',
  Typename = 'typename',
}

export type Pair = {
  __typename?: 'Pair';
  dailyEntities: Array<PairDailyData>;
  /** ID is recreated following the next pattern to standardize pair IDs: <LOWEST Token ID>-<HIGHEST Token ID> */
  id: Scalars['ID'];
  /** ID represented as a decimal number. Follows the same pattern but with a comma instead */
  internalID: Scalars['BigDecimal'];
  swaps: Array<Swap>;
  token0: Token;
  /** Last price of Token 0. Denominated in Token 1 */
  token0Price: Scalars['BigInt'];
  token1: Token;
  /** Last price of Token 1. Denominated in Token 0 */
  token1Price: Scalars['BigInt'];
  /** Total traded volume of token0 within this pair. Includes both Swaps and Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken0: Scalars['BigInt'];
  /** Total traded volume of token0 within this pair exclusively on Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken0Orderbook: Scalars['BigInt'];
  /** Total traded volume of token0 within this pair exclusively on Swaps. Denominated in it's own currency */
  tradedVolumeToken0Swap: Scalars['BigInt'];
  /** Total traded volume of token1 within this pair. Includes both Swaps and Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken1: Scalars['BigInt'];
  /** Total traded volume of token1 within this pair exclusively on Orderbook trades. Denominated in it's own currency */
  tradedVolumeToken1Orderbook: Scalars['BigInt'];
  /** Total traded volume of token1 within this pair exclusively on Swaps. Denominated in it's own currency */
  tradedVolumeToken1Swap: Scalars['BigInt'];
  trades: Array<OrderbookTrade>;
  weeklyEntities: Array<PairWeeklyData>;
};

export type PairDailyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PairDailyData_Filter>;
};

export type PairSwapsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Swap_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Swap_Filter>;
};

export type PairTradesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrderbookTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<OrderbookTrade_Filter>;
};

export type PairWeeklyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PairWeeklyData_Filter>;
};

export type PairDailyData = {
  __typename?: 'PairDailyData';
  /** Timestamp of the end of the day. Timezone -> UTC */
  dayEnd: Scalars['BigInt'];
  /** Day number is the amount of days since the start block of Loopring 3.6 (block 11149814) */
  dayNumber: Scalars['Int'];
  /** Timestamp of the start of the day. Timezone -> UTC */
  dayStart: Scalars['BigInt'];
  /** The ID follows this pattern: <PAIR ID>-<DAY NUMBER>. */
  id: Scalars['ID'];
  pair: Pair;
  /** Price for token 0 at the end of the time interval */
  token0PriceClose: Scalars['BigInt'];
  /** Highest price for token 0 during the time interval */
  token0PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 0 during the time interval */
  token0PriceLow: Scalars['BigInt'];
  /** Price for token 0 at the start of the time interval */
  token0PriceOpen: Scalars['BigInt'];
  /** Price for token 1 at the end of the time interval */
  token1PriceClose: Scalars['BigInt'];
  /** Highest price for token 1 during the time interval */
  token1PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 1 during the time interval */
  token1PriceLow: Scalars['BigInt'];
  /** Price for token 1 at the start of the time interval */
  token1PriceOpen: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken0: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Orderbook trades */
  tradedVolumeToken0Orderbook: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Swaps */
  tradedVolumeToken0Swap: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken1: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Orderbook trades */
  tradedVolumeToken1Orderbook: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Swaps */
  tradedVolumeToken1Swap: Scalars['BigInt'];
};

export type PairDailyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  dayEnd?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd_lt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_lte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayNumber?: InputMaybe<Scalars['Int']>;
  dayNumber_gt?: InputMaybe<Scalars['Int']>;
  dayNumber_gte?: InputMaybe<Scalars['Int']>;
  dayNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  dayNumber_lt?: InputMaybe<Scalars['Int']>;
  dayNumber_lte?: InputMaybe<Scalars['Int']>;
  dayNumber_not?: InputMaybe<Scalars['Int']>;
  dayNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  dayStart?: InputMaybe<Scalars['BigInt']>;
  dayStart_gt?: InputMaybe<Scalars['BigInt']>;
  dayStart_gte?: InputMaybe<Scalars['BigInt']>;
  dayStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayStart_lt?: InputMaybe<Scalars['BigInt']>;
  dayStart_lte?: InputMaybe<Scalars['BigInt']>;
  dayStart_not?: InputMaybe<Scalars['BigInt']>;
  dayStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  pair?: InputMaybe<Scalars['String']>;
  pair_?: InputMaybe<Pair_Filter>;
  pair_contains?: InputMaybe<Scalars['String']>;
  pair_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_ends_with?: InputMaybe<Scalars['String']>;
  pair_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_gt?: InputMaybe<Scalars['String']>;
  pair_gte?: InputMaybe<Scalars['String']>;
  pair_in?: InputMaybe<Array<Scalars['String']>>;
  pair_lt?: InputMaybe<Scalars['String']>;
  pair_lte?: InputMaybe<Scalars['String']>;
  pair_not?: InputMaybe<Scalars['String']>;
  pair_not_contains?: InputMaybe<Scalars['String']>;
  pair_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_not_ends_with?: InputMaybe<Scalars['String']>;
  pair_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_not_in?: InputMaybe<Array<Scalars['String']>>;
  pair_not_starts_with?: InputMaybe<Scalars['String']>;
  pair_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pair_starts_with?: InputMaybe<Scalars['String']>;
  pair_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token0PriceClose?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum PairDailyData_OrderBy {
  DayEnd = 'dayEnd',
  DayNumber = 'dayNumber',
  DayStart = 'dayStart',
  Id = 'id',
  Pair = 'pair',
  Token0PriceClose = 'token0PriceClose',
  Token0PriceHigh = 'token0PriceHigh',
  Token0PriceLow = 'token0PriceLow',
  Token0PriceOpen = 'token0PriceOpen',
  Token1PriceClose = 'token1PriceClose',
  Token1PriceHigh = 'token1PriceHigh',
  Token1PriceLow = 'token1PriceLow',
  Token1PriceOpen = 'token1PriceOpen',
  TradedVolumeToken0 = 'tradedVolumeToken0',
  TradedVolumeToken0Orderbook = 'tradedVolumeToken0Orderbook',
  TradedVolumeToken0Swap = 'tradedVolumeToken0Swap',
  TradedVolumeToken1 = 'tradedVolumeToken1',
  TradedVolumeToken1Orderbook = 'tradedVolumeToken1Orderbook',
  TradedVolumeToken1Swap = 'tradedVolumeToken1Swap',
}

export type PairWeeklyData = {
  __typename?: 'PairWeeklyData';
  /** The ID follows this pattern: <PAIR ID>-<WEEK NUMBER>. */
  id: Scalars['ID'];
  pair: Pair;
  /** Price for token 0 at the end of the time interval */
  token0PriceClose: Scalars['BigInt'];
  /** Highest price for token 0 during the time interval */
  token0PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 0 during the time interval */
  token0PriceLow: Scalars['BigInt'];
  /** Price for token 0 at the start of the time interval */
  token0PriceOpen: Scalars['BigInt'];
  /** Price for token 1 at the end of the time interval */
  token1PriceClose: Scalars['BigInt'];
  /** Highest price for token 1 during the time interval */
  token1PriceHigh: Scalars['BigInt'];
  /** Lowest price for token 1 during the time interval */
  token1PriceLow: Scalars['BigInt'];
  /** Price for token 1 at the start of the time interval */
  token1PriceOpen: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken0: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Orderbook trades */
  tradedVolumeToken0Orderbook: Scalars['BigInt'];
  /** Volume traded for the token0 of the pair exclusively on Swaps */
  tradedVolumeToken0Swap: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair. Includes both Swaps and Orderbook trades */
  tradedVolumeToken1: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Orderbook trades */
  tradedVolumeToken1Orderbook: Scalars['BigInt'];
  /** Volume traded for the token1 of the pair exclusively on Swaps */
  tradedVolumeToken1Swap: Scalars['BigInt'];
  /** Timestamp of the end of the week. Timezone -> UTC */
  weekEnd: Scalars['BigInt'];
  /** Week number is the amount of weeks since the start block of Loopring 3.6 (block 11149814) */
  weekNumber: Scalars['Int'];
  /** Timestamp of the start of the week. Timezone -> UTC */
  weekStart: Scalars['BigInt'];
};

export type PairWeeklyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  pair?: InputMaybe<Scalars['String']>;
  pair_?: InputMaybe<Pair_Filter>;
  pair_contains?: InputMaybe<Scalars['String']>;
  pair_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_ends_with?: InputMaybe<Scalars['String']>;
  pair_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_gt?: InputMaybe<Scalars['String']>;
  pair_gte?: InputMaybe<Scalars['String']>;
  pair_in?: InputMaybe<Array<Scalars['String']>>;
  pair_lt?: InputMaybe<Scalars['String']>;
  pair_lte?: InputMaybe<Scalars['String']>;
  pair_not?: InputMaybe<Scalars['String']>;
  pair_not_contains?: InputMaybe<Scalars['String']>;
  pair_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_not_ends_with?: InputMaybe<Scalars['String']>;
  pair_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_not_in?: InputMaybe<Array<Scalars['String']>>;
  pair_not_starts_with?: InputMaybe<Scalars['String']>;
  pair_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pair_starts_with?: InputMaybe<Scalars['String']>;
  pair_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token0PriceClose?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token0PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceClose_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceClose_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceHigh_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceHigh_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceLow_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceLow_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_gte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1PriceOpen_lt?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_lte?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not?: InputMaybe<Scalars['BigInt']>;
  token1PriceOpen_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd_lt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_lte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekNumber?: InputMaybe<Scalars['Int']>;
  weekNumber_gt?: InputMaybe<Scalars['Int']>;
  weekNumber_gte?: InputMaybe<Scalars['Int']>;
  weekNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  weekNumber_lt?: InputMaybe<Scalars['Int']>;
  weekNumber_lte?: InputMaybe<Scalars['Int']>;
  weekNumber_not?: InputMaybe<Scalars['Int']>;
  weekNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  weekStart?: InputMaybe<Scalars['BigInt']>;
  weekStart_gt?: InputMaybe<Scalars['BigInt']>;
  weekStart_gte?: InputMaybe<Scalars['BigInt']>;
  weekStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekStart_lt?: InputMaybe<Scalars['BigInt']>;
  weekStart_lte?: InputMaybe<Scalars['BigInt']>;
  weekStart_not?: InputMaybe<Scalars['BigInt']>;
  weekStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum PairWeeklyData_OrderBy {
  Id = 'id',
  Pair = 'pair',
  Token0PriceClose = 'token0PriceClose',
  Token0PriceHigh = 'token0PriceHigh',
  Token0PriceLow = 'token0PriceLow',
  Token0PriceOpen = 'token0PriceOpen',
  Token1PriceClose = 'token1PriceClose',
  Token1PriceHigh = 'token1PriceHigh',
  Token1PriceLow = 'token1PriceLow',
  Token1PriceOpen = 'token1PriceOpen',
  TradedVolumeToken0 = 'tradedVolumeToken0',
  TradedVolumeToken0Orderbook = 'tradedVolumeToken0Orderbook',
  TradedVolumeToken0Swap = 'tradedVolumeToken0Swap',
  TradedVolumeToken1 = 'tradedVolumeToken1',
  TradedVolumeToken1Orderbook = 'tradedVolumeToken1Orderbook',
  TradedVolumeToken1Swap = 'tradedVolumeToken1Swap',
  WeekEnd = 'weekEnd',
  WeekNumber = 'weekNumber',
  WeekStart = 'weekStart',
}

export type Pair_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  dailyEntities_?: InputMaybe<PairDailyData_Filter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  swaps_?: InputMaybe<Swap_Filter>;
  token0?: InputMaybe<Scalars['String']>;
  token0Price?: InputMaybe<Scalars['BigInt']>;
  token0Price_gt?: InputMaybe<Scalars['BigInt']>;
  token0Price_gte?: InputMaybe<Scalars['BigInt']>;
  token0Price_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0Price_lt?: InputMaybe<Scalars['BigInt']>;
  token0Price_lte?: InputMaybe<Scalars['BigInt']>;
  token0Price_not?: InputMaybe<Scalars['BigInt']>;
  token0Price_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token0_?: InputMaybe<Token_Filter>;
  token0_contains?: InputMaybe<Scalars['String']>;
  token0_contains_nocase?: InputMaybe<Scalars['String']>;
  token0_ends_with?: InputMaybe<Scalars['String']>;
  token0_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token0_gt?: InputMaybe<Scalars['String']>;
  token0_gte?: InputMaybe<Scalars['String']>;
  token0_in?: InputMaybe<Array<Scalars['String']>>;
  token0_lt?: InputMaybe<Scalars['String']>;
  token0_lte?: InputMaybe<Scalars['String']>;
  token0_not?: InputMaybe<Scalars['String']>;
  token0_not_contains?: InputMaybe<Scalars['String']>;
  token0_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token0_not_ends_with?: InputMaybe<Scalars['String']>;
  token0_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token0_not_in?: InputMaybe<Array<Scalars['String']>>;
  token0_not_starts_with?: InputMaybe<Scalars['String']>;
  token0_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token0_starts_with?: InputMaybe<Scalars['String']>;
  token0_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token1?: InputMaybe<Scalars['String']>;
  token1Price?: InputMaybe<Scalars['BigInt']>;
  token1Price_gt?: InputMaybe<Scalars['BigInt']>;
  token1Price_gte?: InputMaybe<Scalars['BigInt']>;
  token1Price_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1Price_lt?: InputMaybe<Scalars['BigInt']>;
  token1Price_lte?: InputMaybe<Scalars['BigInt']>;
  token1Price_not?: InputMaybe<Scalars['BigInt']>;
  token1Price_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token1_?: InputMaybe<Token_Filter>;
  token1_contains?: InputMaybe<Scalars['String']>;
  token1_contains_nocase?: InputMaybe<Scalars['String']>;
  token1_ends_with?: InputMaybe<Scalars['String']>;
  token1_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token1_gt?: InputMaybe<Scalars['String']>;
  token1_gte?: InputMaybe<Scalars['String']>;
  token1_in?: InputMaybe<Array<Scalars['String']>>;
  token1_lt?: InputMaybe<Scalars['String']>;
  token1_lte?: InputMaybe<Scalars['String']>;
  token1_not?: InputMaybe<Scalars['String']>;
  token1_not_contains?: InputMaybe<Scalars['String']>;
  token1_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token1_not_ends_with?: InputMaybe<Scalars['String']>;
  token1_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token1_not_in?: InputMaybe<Array<Scalars['String']>>;
  token1_not_starts_with?: InputMaybe<Scalars['String']>;
  token1_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token1_starts_with?: InputMaybe<Scalars['String']>;
  token1_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolumeToken0?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken0_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken0_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Orderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Orderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1Swap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1Swap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeToken1_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeToken1_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  trades_?: InputMaybe<OrderbookTrade_Filter>;
  weeklyEntities_?: InputMaybe<PairWeeklyData_Filter>;
};

export enum Pair_OrderBy {
  DailyEntities = 'dailyEntities',
  Id = 'id',
  InternalId = 'internalID',
  Swaps = 'swaps',
  Token0 = 'token0',
  Token0Price = 'token0Price',
  Token1 = 'token1',
  Token1Price = 'token1Price',
  TradedVolumeToken0 = 'tradedVolumeToken0',
  TradedVolumeToken0Orderbook = 'tradedVolumeToken0Orderbook',
  TradedVolumeToken0Swap = 'tradedVolumeToken0Swap',
  TradedVolumeToken1 = 'tradedVolumeToken1',
  TradedVolumeToken1Orderbook = 'tradedVolumeToken1Orderbook',
  TradedVolumeToken1Swap = 'tradedVolumeToken1Swap',
  Trades = 'trades',
  WeeklyEntities = 'weeklyEntities',
}

export type Pool = Account & {
  __typename?: 'Pool';
  address: Scalars['Bytes'];
  balances: Array<AccountTokenBalance>;
  /** L2 transaction internalID where the account was first created and linked to an address. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the account was first created and linked to an address */
  createdAtTransaction: Transaction;
  feeBipsAMM?: Maybe<Scalars['Int']>;
  /** Internal ID used in the L2 transactions */
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt for sorting purposes */
  internalID: Scalars['BigInt'];
  /** L2 transaction internalID that last updated the account entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the account entity */
  lastUpdatedAtTransaction: Transaction;
  /** List of all the AccountNFTSlot entities that this account has. Those slots can be empty but will only exist if they held an NFT at some point. */
  slots: Array<AccountNftSlot>;
  /** L2 transactions that involved this account */
  transactions: Array<Transaction>;
};

export type PoolBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type PoolSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type PoolTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type Pool_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  balances_?: InputMaybe<AccountTokenBalance_Filter>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  feeBipsAMM?: InputMaybe<Scalars['Int']>;
  feeBipsAMM_gt?: InputMaybe<Scalars['Int']>;
  feeBipsAMM_gte?: InputMaybe<Scalars['Int']>;
  feeBipsAMM_in?: InputMaybe<Array<Scalars['Int']>>;
  feeBipsAMM_lt?: InputMaybe<Scalars['Int']>;
  feeBipsAMM_lte?: InputMaybe<Scalars['Int']>;
  feeBipsAMM_not?: InputMaybe<Scalars['Int']>;
  feeBipsAMM_not_in?: InputMaybe<Array<Scalars['Int']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  transactions_?: InputMaybe<Transaction_Filter>;
};

export enum Pool_OrderBy {
  Address = 'address',
  Balances = 'balances',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  FeeBipsAmm = 'feeBipsAMM',
  Id = 'id',
  InternalId = 'internalID',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  Slots = 'slots',
  Transactions = 'transactions',
}

export type ProtocolAccount = Account & {
  __typename?: 'ProtocolAccount';
  address: Scalars['Bytes'];
  balances: Array<AccountTokenBalance>;
  /** L2 transaction internalID where the account was first created and linked to an address. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the account was first created and linked to an address */
  createdAtTransaction: Transaction;
  /** ID is always 0 since there's only a single ProtocolAccount and uses the reserved id 0 */
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt for sorting purposes */
  internalID: Scalars['BigInt'];
  /** L2 transaction internalID that last updated the account entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the account entity */
  lastUpdatedAtTransaction: Transaction;
  /** List of all the AccountNFTSlot entities that this account has. Those slots can be empty but will only exist if they held an NFT at some point. */
  slots: Array<AccountNftSlot>;
  /** L2 transactions that involved this account */
  transactions: Array<Transaction>;
};

export type ProtocolAccountBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type ProtocolAccountSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type ProtocolAccountTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type ProtocolAccount_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  balances_?: InputMaybe<AccountTokenBalance_Filter>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  transactions_?: InputMaybe<Transaction_Filter>;
};

export enum ProtocolAccount_OrderBy {
  Address = 'address',
  Balances = 'balances',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  Id = 'id',
  InternalId = 'internalID',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  Slots = 'slots',
  Transactions = 'transactions',
}

export type Proxy = {
  __typename?: 'Proxy';
  /** Total amount of AccountUpdate transactions processed across all blocks */
  accountUpdateCount: Scalars['BigInt'];
  /** Total amount of Add transactions processed across all blocks */
  addCount: Scalars['BigInt'];
  /** Total amount of AMMUpdate transactions processed across all blocks */
  ammUpdateCount: Scalars['BigInt'];
  /** Total amount of blocks processed */
  blockCount: Scalars['BigInt'];
  /** Current implementation is represented by a link to the current Exchange entity */
  currentImplementation?: Maybe<Exchange>;
  /** Total amount of Deposit transactions processed across all blocks */
  depositCount: Scalars['BigInt'];
  /** Proxy ID is always '0' since it's a singleton entity. */
  id: Scalars['ID'];
  /** List of all historical Exchange entities */
  implementations: Array<Exchange>;
  /** Total amount of unique NFTs */
  nftCount: Scalars['BigInt'];
  /** Total amount of NFT Data transactions processed across all blocks */
  nftDataCount: Scalars['BigInt'];
  /** Total amount of NFT Mint transactions processed across all blocks */
  nftMintCount: Scalars['BigInt'];
  /** Total amount of OrderbookTrade transactions processed across all blocks */
  orderbookTradeCount: Scalars['BigInt'];
  /** Total amount of unique Pool entities */
  poolCount: Scalars['BigInt'];
  /** Total amount of Remove transactions processed across all blocks */
  removeCount: Scalars['BigInt'];
  /** Total amount of SignatureVerification transactions processed across all blocks */
  signatureVerificationCount: Scalars['BigInt'];
  /** Total amount of Swap transactions processed across all blocks */
  swapCount: Scalars['BigInt'];
  /** Total amount of SwapNFT transactions processed across all blocks */
  swapNFTCount: Scalars['BigInt'];
  /** Total amount of tokens supported */
  tokenCount: Scalars['BigInt'];
  /** Total amount of TradeNFT transactions processed across all blocks */
  tradeNFTCount: Scalars['BigInt'];
  /** Total amount of transactions processed across all blocks */
  transactionCount: Scalars['BigInt'];
  /** Total amount of Transfer transactions processed across all blocks */
  transferCount: Scalars['BigInt'];
  /** Total amount of TransferNFT transactions processed across all blocks */
  transferNFTCount: Scalars['BigInt'];
  /** Total amount of unique User entities */
  userCount: Scalars['BigInt'];
  /** Total amount of Withdrawal transactions processed across all blocks */
  withdrawalCount: Scalars['BigInt'];
  /** Total amount of WithdrawalNFT transactions processed across all blocks */
  withdrawalNFTCount: Scalars['BigInt'];
};

export type ProxyImplementationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Exchange_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Exchange_Filter>;
};

export type Proxy_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountUpdateCount?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_gte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  accountUpdateCount_lt?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_lte?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not?: InputMaybe<Scalars['BigInt']>;
  accountUpdateCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addCount?: InputMaybe<Scalars['BigInt']>;
  addCount_gt?: InputMaybe<Scalars['BigInt']>;
  addCount_gte?: InputMaybe<Scalars['BigInt']>;
  addCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addCount_lt?: InputMaybe<Scalars['BigInt']>;
  addCount_lte?: InputMaybe<Scalars['BigInt']>;
  addCount_not?: InputMaybe<Scalars['BigInt']>;
  addCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  ammUpdateCount?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_gt?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_gte?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  ammUpdateCount_lt?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_lte?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_not?: InputMaybe<Scalars['BigInt']>;
  ammUpdateCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockCount?: InputMaybe<Scalars['BigInt']>;
  blockCount_gt?: InputMaybe<Scalars['BigInt']>;
  blockCount_gte?: InputMaybe<Scalars['BigInt']>;
  blockCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockCount_lt?: InputMaybe<Scalars['BigInt']>;
  blockCount_lte?: InputMaybe<Scalars['BigInt']>;
  blockCount_not?: InputMaybe<Scalars['BigInt']>;
  blockCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  currentImplementation?: InputMaybe<Scalars['String']>;
  currentImplementation_?: InputMaybe<Exchange_Filter>;
  currentImplementation_contains?: InputMaybe<Scalars['String']>;
  currentImplementation_contains_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_ends_with?: InputMaybe<Scalars['String']>;
  currentImplementation_ends_with_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_gt?: InputMaybe<Scalars['String']>;
  currentImplementation_gte?: InputMaybe<Scalars['String']>;
  currentImplementation_in?: InputMaybe<Array<Scalars['String']>>;
  currentImplementation_lt?: InputMaybe<Scalars['String']>;
  currentImplementation_lte?: InputMaybe<Scalars['String']>;
  currentImplementation_not?: InputMaybe<Scalars['String']>;
  currentImplementation_not_contains?: InputMaybe<Scalars['String']>;
  currentImplementation_not_contains_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_not_ends_with?: InputMaybe<Scalars['String']>;
  currentImplementation_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_not_in?: InputMaybe<Array<Scalars['String']>>;
  currentImplementation_not_starts_with?: InputMaybe<Scalars['String']>;
  currentImplementation_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  currentImplementation_starts_with?: InputMaybe<Scalars['String']>;
  currentImplementation_starts_with_nocase?: InputMaybe<Scalars['String']>;
  depositCount?: InputMaybe<Scalars['BigInt']>;
  depositCount_gt?: InputMaybe<Scalars['BigInt']>;
  depositCount_gte?: InputMaybe<Scalars['BigInt']>;
  depositCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  depositCount_lt?: InputMaybe<Scalars['BigInt']>;
  depositCount_lte?: InputMaybe<Scalars['BigInt']>;
  depositCount_not?: InputMaybe<Scalars['BigInt']>;
  depositCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  implementations_?: InputMaybe<Exchange_Filter>;
  nftCount?: InputMaybe<Scalars['BigInt']>;
  nftCount_gt?: InputMaybe<Scalars['BigInt']>;
  nftCount_gte?: InputMaybe<Scalars['BigInt']>;
  nftCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftCount_lt?: InputMaybe<Scalars['BigInt']>;
  nftCount_lte?: InputMaybe<Scalars['BigInt']>;
  nftCount_not?: InputMaybe<Scalars['BigInt']>;
  nftCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftDataCount?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_gt?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_gte?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftDataCount_lt?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_lte?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_not?: InputMaybe<Scalars['BigInt']>;
  nftDataCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftMintCount?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_gt?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_gte?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nftMintCount_lt?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_lte?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_not?: InputMaybe<Scalars['BigInt']>;
  nftMintCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderbookTradeCount?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_gte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderbookTradeCount_lt?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_lte?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not?: InputMaybe<Scalars['BigInt']>;
  orderbookTradeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  poolCount?: InputMaybe<Scalars['BigInt']>;
  poolCount_gt?: InputMaybe<Scalars['BigInt']>;
  poolCount_gte?: InputMaybe<Scalars['BigInt']>;
  poolCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  poolCount_lt?: InputMaybe<Scalars['BigInt']>;
  poolCount_lte?: InputMaybe<Scalars['BigInt']>;
  poolCount_not?: InputMaybe<Scalars['BigInt']>;
  poolCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  removeCount?: InputMaybe<Scalars['BigInt']>;
  removeCount_gt?: InputMaybe<Scalars['BigInt']>;
  removeCount_gte?: InputMaybe<Scalars['BigInt']>;
  removeCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  removeCount_lt?: InputMaybe<Scalars['BigInt']>;
  removeCount_lte?: InputMaybe<Scalars['BigInt']>;
  removeCount_not?: InputMaybe<Scalars['BigInt']>;
  removeCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_gte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  signatureVerificationCount_lt?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_lte?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not?: InputMaybe<Scalars['BigInt']>;
  signatureVerificationCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapCount?: InputMaybe<Scalars['BigInt']>;
  swapCount_gt?: InputMaybe<Scalars['BigInt']>;
  swapCount_gte?: InputMaybe<Scalars['BigInt']>;
  swapCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapCount_lt?: InputMaybe<Scalars['BigInt']>;
  swapCount_lte?: InputMaybe<Scalars['BigInt']>;
  swapCount_not?: InputMaybe<Scalars['BigInt']>;
  swapCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapNFTCount?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  swapNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  swapNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenCount?: InputMaybe<Scalars['BigInt']>;
  tokenCount_gt?: InputMaybe<Scalars['BigInt']>;
  tokenCount_gte?: InputMaybe<Scalars['BigInt']>;
  tokenCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenCount_lt?: InputMaybe<Scalars['BigInt']>;
  tokenCount_lte?: InputMaybe<Scalars['BigInt']>;
  tokenCount_not?: InputMaybe<Scalars['BigInt']>;
  tokenCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradeNFTCount?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradeNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  tradeNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_gte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionCount_lt?: InputMaybe<Scalars['BigInt']>;
  transactionCount_lte?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not?: InputMaybe<Scalars['BigInt']>;
  transactionCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferCount?: InputMaybe<Scalars['BigInt']>;
  transferCount_gt?: InputMaybe<Scalars['BigInt']>;
  transferCount_gte?: InputMaybe<Scalars['BigInt']>;
  transferCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferCount_lt?: InputMaybe<Scalars['BigInt']>;
  transferCount_lte?: InputMaybe<Scalars['BigInt']>;
  transferCount_not?: InputMaybe<Scalars['BigInt']>;
  transferCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferNFTCount?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transferNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  transferNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  userCount?: InputMaybe<Scalars['BigInt']>;
  userCount_gt?: InputMaybe<Scalars['BigInt']>;
  userCount_gte?: InputMaybe<Scalars['BigInt']>;
  userCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  userCount_lt?: InputMaybe<Scalars['BigInt']>;
  userCount_lte?: InputMaybe<Scalars['BigInt']>;
  userCount_not?: InputMaybe<Scalars['BigInt']>;
  userCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalCount?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_gte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalCount_lt?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_lte?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not?: InputMaybe<Scalars['BigInt']>;
  withdrawalCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalNFTCount?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_gt?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_gte?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  withdrawalNFTCount_lt?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_lte?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_not?: InputMaybe<Scalars['BigInt']>;
  withdrawalNFTCount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum Proxy_OrderBy {
  AccountUpdateCount = 'accountUpdateCount',
  AddCount = 'addCount',
  AmmUpdateCount = 'ammUpdateCount',
  BlockCount = 'blockCount',
  CurrentImplementation = 'currentImplementation',
  DepositCount = 'depositCount',
  Id = 'id',
  Implementations = 'implementations',
  NftCount = 'nftCount',
  NftDataCount = 'nftDataCount',
  NftMintCount = 'nftMintCount',
  OrderbookTradeCount = 'orderbookTradeCount',
  PoolCount = 'poolCount',
  RemoveCount = 'removeCount',
  SignatureVerificationCount = 'signatureVerificationCount',
  SwapCount = 'swapCount',
  SwapNftCount = 'swapNFTCount',
  TokenCount = 'tokenCount',
  TradeNftCount = 'tradeNFTCount',
  TransactionCount = 'transactionCount',
  TransferCount = 'transferCount',
  TransferNftCount = 'transferNFTCount',
  UserCount = 'userCount',
  WithdrawalCount = 'withdrawalCount',
  WithdrawalNftCount = 'withdrawalNFTCount',
}

export type Query = {
  __typename?: 'Query';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  account?: Maybe<Account>;
  accountNFTSlot?: Maybe<AccountNftSlot>;
  accountNFTSlots: Array<AccountNftSlot>;
  accountTokenBalance?: Maybe<AccountTokenBalance>;
  accountTokenBalanceDailyData?: Maybe<AccountTokenBalanceDailyData>;
  accountTokenBalanceDailyDatas: Array<AccountTokenBalanceDailyData>;
  accountTokenBalanceWeeklyData?: Maybe<AccountTokenBalanceWeeklyData>;
  accountTokenBalanceWeeklyDatas: Array<AccountTokenBalanceWeeklyData>;
  accountTokenBalances: Array<AccountTokenBalance>;
  accountUpdate?: Maybe<AccountUpdate>;
  accountUpdates: Array<AccountUpdate>;
  accounts: Array<Account>;
  add?: Maybe<Add>;
  adds: Array<Add>;
  ammUpdate?: Maybe<AmmUpdate>;
  ammUpdates: Array<AmmUpdate>;
  block?: Maybe<Block>;
  blocks: Array<Block>;
  dataNFT?: Maybe<DataNft>;
  dataNFTs: Array<DataNft>;
  deposit?: Maybe<Deposit>;
  deposits: Array<Deposit>;
  exchange?: Maybe<Exchange>;
  exchanges: Array<Exchange>;
  mintNFT?: Maybe<MintNft>;
  mintNFTs: Array<MintNft>;
  nonFungibleToken?: Maybe<NonFungibleToken>;
  nonFungibleTokens: Array<NonFungibleToken>;
  orderbookTrade?: Maybe<OrderbookTrade>;
  orderbookTrades: Array<OrderbookTrade>;
  pair?: Maybe<Pair>;
  pairDailyData?: Maybe<PairDailyData>;
  pairDailyDatas: Array<PairDailyData>;
  pairWeeklyData?: Maybe<PairWeeklyData>;
  pairWeeklyDatas: Array<PairWeeklyData>;
  pairs: Array<Pair>;
  pool?: Maybe<Pool>;
  pools: Array<Pool>;
  protocolAccount?: Maybe<ProtocolAccount>;
  protocolAccounts: Array<ProtocolAccount>;
  proxies: Array<Proxy>;
  proxy?: Maybe<Proxy>;
  remove?: Maybe<Remove>;
  removes: Array<Remove>;
  signatureVerification?: Maybe<SignatureVerification>;
  signatureVerifications: Array<SignatureVerification>;
  swap?: Maybe<Swap>;
  swapNFT?: Maybe<SwapNft>;
  swapNFTs: Array<SwapNft>;
  swaps: Array<Swap>;
  token?: Maybe<Token>;
  tokenDailyData?: Maybe<TokenDailyData>;
  tokenDailyDatas: Array<TokenDailyData>;
  tokenWeeklyData?: Maybe<TokenWeeklyData>;
  tokenWeeklyDatas: Array<TokenWeeklyData>;
  tokens: Array<Token>;
  tradeNFT?: Maybe<TradeNft>;
  tradeNFTs: Array<TradeNft>;
  transaction?: Maybe<Transaction>;
  transactionNFT?: Maybe<TransactionNft>;
  transactionNFTs: Array<TransactionNft>;
  transactions: Array<Transaction>;
  transfer?: Maybe<Transfer>;
  transferNFT?: Maybe<TransferNft>;
  transferNFTs: Array<TransferNft>;
  transfers: Array<Transfer>;
  user?: Maybe<User>;
  users: Array<User>;
  withdrawal?: Maybe<Withdrawal>;
  withdrawalNFT?: Maybe<WithdrawalNft>;
  withdrawalNFTs: Array<WithdrawalNft>;
  withdrawals: Array<Withdrawal>;
};

export type Query_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};

export type QueryAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountNftSlotArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountNftSlotsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type QueryAccountTokenBalanceArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountTokenBalanceDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountTokenBalanceDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
};

export type QueryAccountTokenBalanceWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountTokenBalanceWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export type QueryAccountTokenBalancesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type QueryAccountUpdateArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAccountUpdatesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountUpdate_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountUpdate_Filter>;
};

export type QueryAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Account_Filter>;
};

export type QueryAddArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAddsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Add_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Add_Filter>;
};

export type QueryAmmUpdateArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryAmmUpdatesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AmmUpdate_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AmmUpdate_Filter>;
};

export type QueryBlockArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryBlocksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Block_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Block_Filter>;
};

export type QueryDataNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryDataNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DataNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<DataNft_Filter>;
};

export type QueryDepositArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryDepositsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Deposit_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Deposit_Filter>;
};

export type QueryExchangeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryExchangesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Exchange_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Exchange_Filter>;
};

export type QueryMintNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryMintNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MintNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<MintNft_Filter>;
};

export type QueryNonFungibleTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryNonFungibleTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type QueryOrderbookTradeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryOrderbookTradesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrderbookTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<OrderbookTrade_Filter>;
};

export type QueryPairArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryPairDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryPairDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairDailyData_Filter>;
};

export type QueryPairWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryPairWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairWeeklyData_Filter>;
};

export type QueryPairsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Pair_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pair_Filter>;
};

export type QueryPoolArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryPoolsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Pool_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pool_Filter>;
};

export type QueryProtocolAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryProtocolAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProtocolAccount_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ProtocolAccount_Filter>;
};

export type QueryProxiesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Proxy_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Proxy_Filter>;
};

export type QueryProxyArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryRemoveArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryRemovesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Remove_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Remove_Filter>;
};

export type QuerySignatureVerificationArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerySignatureVerificationsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SignatureVerification_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SignatureVerification_Filter>;
};

export type QuerySwapArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerySwapNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QuerySwapNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SwapNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SwapNft_Filter>;
};

export type QuerySwapsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Swap_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Swap_Filter>;
};

export type QueryTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTokenDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTokenDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDailyData_Filter>;
};

export type QueryTokenWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTokenWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenWeeklyData_Filter>;
};

export type QueryTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};

export type QueryTradeNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTradeNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TradeNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TradeNft_Filter>;
};

export type QueryTransactionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTransactionNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTransactionNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TransactionNft_Filter>;
};

export type QueryTransactionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transaction_Filter>;
};

export type QueryTransferArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTransferNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryTransferNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransferNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TransferNft_Filter>;
};

export type QueryTransfersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transfer_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transfer_Filter>;
};

export type QueryUserArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryUsersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<User_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<User_Filter>;
};

export type QueryWithdrawalArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryWithdrawalNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type QueryWithdrawalNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WithdrawalNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<WithdrawalNft_Filter>;
};

export type QueryWithdrawalsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Withdrawal_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Withdrawal_Filter>;
};

export type Remove = Transaction & {
  __typename?: 'Remove';
  /** Account entity that triggered the removal of liquidity from the pool */
  account: Account;
  /** [RAW L2 DATA] Account ID for the account that sent the tokens */
  accountFromID: Scalars['Int'];
  /** [RAW L2 DATA] Account ID for the account that received the tokens */
  accountToID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount transfered */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken: Token;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that sent the tokens */
  from: Scalars['String'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** Pool entity where the liquidity was removed */
  pool: Pool;
  /** [RAW L2 DATA] StorageID */
  storageID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that received the tokens */
  to: Scalars['String'];
  /** [RAW L2 DATA] Token ID of the token transfered. Mainly used for NFT transfers */
  toTokenID: Scalars['Int'];
  /** Token entity with information about the token transfered */
  token: Token;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the token transfered */
  tokenID: Scalars['Int'];
  /** [RAW L2 DATA] Transfer type */
  type: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type RemoveAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type RemoveTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type Remove_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountFromID?: InputMaybe<Scalars['Int']>;
  accountFromID_gt?: InputMaybe<Scalars['Int']>;
  accountFromID_gte?: InputMaybe<Scalars['Int']>;
  accountFromID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFromID_lt?: InputMaybe<Scalars['Int']>;
  accountFromID_lte?: InputMaybe<Scalars['Int']>;
  accountFromID_not?: InputMaybe<Scalars['Int']>;
  accountFromID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID?: InputMaybe<Scalars['Int']>;
  accountToID_gt?: InputMaybe<Scalars['Int']>;
  accountToID_gte?: InputMaybe<Scalars['Int']>;
  accountToID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID_lt?: InputMaybe<Scalars['Int']>;
  accountToID_lte?: InputMaybe<Scalars['Int']>;
  accountToID_not?: InputMaybe<Scalars['Int']>;
  accountToID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  pool?: InputMaybe<Scalars['String']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_ends_with?: InputMaybe<Scalars['String']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_gt?: InputMaybe<Scalars['String']>;
  pool_gte?: InputMaybe<Scalars['String']>;
  pool_in?: InputMaybe<Array<Scalars['String']>>;
  pool_lt?: InputMaybe<Scalars['String']>;
  pool_lte?: InputMaybe<Scalars['String']>;
  pool_not?: InputMaybe<Scalars['String']>;
  pool_not_contains?: InputMaybe<Scalars['String']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pool_starts_with?: InputMaybe<Scalars['String']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to?: InputMaybe<Scalars['String']>;
  toTokenID?: InputMaybe<Scalars['Int']>;
  toTokenID_gt?: InputMaybe<Scalars['Int']>;
  toTokenID_gte?: InputMaybe<Scalars['Int']>;
  toTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  toTokenID_lt?: InputMaybe<Scalars['Int']>;
  toTokenID_lte?: InputMaybe<Scalars['Int']>;
  toTokenID_not?: InputMaybe<Scalars['Int']>;
  toTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Remove_OrderBy {
  Account = 'account',
  AccountFromId = 'accountFromID',
  AccountToId = 'accountToID',
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  From = 'from',
  Id = 'id',
  InternalId = 'internalID',
  Pool = 'pool',
  StorageId = 'storageID',
  To = 'to',
  ToTokenId = 'toTokenID',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Type = 'type',
  Typename = 'typename',
}

export type SignatureVerification = Transaction & {
  __typename?: 'SignatureVerification';
  /** Account entity updated in this transaction */
  account: Account;
  /** [RAW L2 DATA] Account ID of the pool account updated */
  accountID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  block: Block;
  data: Scalars['String'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Address of the account updated */
  owner: Scalars['String'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
  /** [RAW L2 DATA] Signature verification data */
  verificationData: Scalars['String'];
};

export type SignatureVerificationAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type SignatureVerificationTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type SignatureVerification_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountID?: InputMaybe<Scalars['Int']>;
  accountID_gt?: InputMaybe<Scalars['Int']>;
  accountID_gte?: InputMaybe<Scalars['Int']>;
  accountID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountID_lt?: InputMaybe<Scalars['Int']>;
  accountID_lte?: InputMaybe<Scalars['Int']>;
  accountID_not?: InputMaybe<Scalars['Int']>;
  accountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  owner?: InputMaybe<Scalars['String']>;
  owner_contains?: InputMaybe<Scalars['String']>;
  owner_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_ends_with?: InputMaybe<Scalars['String']>;
  owner_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_gt?: InputMaybe<Scalars['String']>;
  owner_gte?: InputMaybe<Scalars['String']>;
  owner_in?: InputMaybe<Array<Scalars['String']>>;
  owner_lt?: InputMaybe<Scalars['String']>;
  owner_lte?: InputMaybe<Scalars['String']>;
  owner_not?: InputMaybe<Scalars['String']>;
  owner_not_contains?: InputMaybe<Scalars['String']>;
  owner_not_contains_nocase?: InputMaybe<Scalars['String']>;
  owner_not_ends_with?: InputMaybe<Scalars['String']>;
  owner_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  owner_not_in?: InputMaybe<Array<Scalars['String']>>;
  owner_not_starts_with?: InputMaybe<Scalars['String']>;
  owner_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  owner_starts_with?: InputMaybe<Scalars['String']>;
  owner_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
  verificationData?: InputMaybe<Scalars['String']>;
  verificationData_contains?: InputMaybe<Scalars['String']>;
  verificationData_contains_nocase?: InputMaybe<Scalars['String']>;
  verificationData_ends_with?: InputMaybe<Scalars['String']>;
  verificationData_ends_with_nocase?: InputMaybe<Scalars['String']>;
  verificationData_gt?: InputMaybe<Scalars['String']>;
  verificationData_gte?: InputMaybe<Scalars['String']>;
  verificationData_in?: InputMaybe<Array<Scalars['String']>>;
  verificationData_lt?: InputMaybe<Scalars['String']>;
  verificationData_lte?: InputMaybe<Scalars['String']>;
  verificationData_not?: InputMaybe<Scalars['String']>;
  verificationData_not_contains?: InputMaybe<Scalars['String']>;
  verificationData_not_contains_nocase?: InputMaybe<Scalars['String']>;
  verificationData_not_ends_with?: InputMaybe<Scalars['String']>;
  verificationData_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  verificationData_not_in?: InputMaybe<Array<Scalars['String']>>;
  verificationData_not_starts_with?: InputMaybe<Scalars['String']>;
  verificationData_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  verificationData_starts_with?: InputMaybe<Scalars['String']>;
  verificationData_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum SignatureVerification_OrderBy {
  Account = 'account',
  AccountId = 'accountID',
  Accounts = 'accounts',
  Block = 'block',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  Owner = 'owner',
  TokenBalances = 'tokenBalances',
  Typename = 'typename',
  VerificationData = 'verificationData',
}

export type Subscription = {
  __typename?: 'Subscription';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  account?: Maybe<Account>;
  accountNFTSlot?: Maybe<AccountNftSlot>;
  accountNFTSlots: Array<AccountNftSlot>;
  accountTokenBalance?: Maybe<AccountTokenBalance>;
  accountTokenBalanceDailyData?: Maybe<AccountTokenBalanceDailyData>;
  accountTokenBalanceDailyDatas: Array<AccountTokenBalanceDailyData>;
  accountTokenBalanceWeeklyData?: Maybe<AccountTokenBalanceWeeklyData>;
  accountTokenBalanceWeeklyDatas: Array<AccountTokenBalanceWeeklyData>;
  accountTokenBalances: Array<AccountTokenBalance>;
  accountUpdate?: Maybe<AccountUpdate>;
  accountUpdates: Array<AccountUpdate>;
  accounts: Array<Account>;
  add?: Maybe<Add>;
  adds: Array<Add>;
  ammUpdate?: Maybe<AmmUpdate>;
  ammUpdates: Array<AmmUpdate>;
  block?: Maybe<Block>;
  blocks: Array<Block>;
  dataNFT?: Maybe<DataNft>;
  dataNFTs: Array<DataNft>;
  deposit?: Maybe<Deposit>;
  deposits: Array<Deposit>;
  exchange?: Maybe<Exchange>;
  exchanges: Array<Exchange>;
  mintNFT?: Maybe<MintNft>;
  mintNFTs: Array<MintNft>;
  nonFungibleToken?: Maybe<NonFungibleToken>;
  nonFungibleTokens: Array<NonFungibleToken>;
  orderbookTrade?: Maybe<OrderbookTrade>;
  orderbookTrades: Array<OrderbookTrade>;
  pair?: Maybe<Pair>;
  pairDailyData?: Maybe<PairDailyData>;
  pairDailyDatas: Array<PairDailyData>;
  pairWeeklyData?: Maybe<PairWeeklyData>;
  pairWeeklyDatas: Array<PairWeeklyData>;
  pairs: Array<Pair>;
  pool?: Maybe<Pool>;
  pools: Array<Pool>;
  protocolAccount?: Maybe<ProtocolAccount>;
  protocolAccounts: Array<ProtocolAccount>;
  proxies: Array<Proxy>;
  proxy?: Maybe<Proxy>;
  remove?: Maybe<Remove>;
  removes: Array<Remove>;
  signatureVerification?: Maybe<SignatureVerification>;
  signatureVerifications: Array<SignatureVerification>;
  swap?: Maybe<Swap>;
  swapNFT?: Maybe<SwapNft>;
  swapNFTs: Array<SwapNft>;
  swaps: Array<Swap>;
  token?: Maybe<Token>;
  tokenDailyData?: Maybe<TokenDailyData>;
  tokenDailyDatas: Array<TokenDailyData>;
  tokenWeeklyData?: Maybe<TokenWeeklyData>;
  tokenWeeklyDatas: Array<TokenWeeklyData>;
  tokens: Array<Token>;
  tradeNFT?: Maybe<TradeNft>;
  tradeNFTs: Array<TradeNft>;
  transaction?: Maybe<Transaction>;
  transactionNFT?: Maybe<TransactionNft>;
  transactionNFTs: Array<TransactionNft>;
  transactions: Array<Transaction>;
  transfer?: Maybe<Transfer>;
  transferNFT?: Maybe<TransferNft>;
  transferNFTs: Array<TransferNft>;
  transfers: Array<Transfer>;
  user?: Maybe<User>;
  users: Array<User>;
  withdrawal?: Maybe<Withdrawal>;
  withdrawalNFT?: Maybe<WithdrawalNft>;
  withdrawalNFTs: Array<WithdrawalNft>;
  withdrawals: Array<Withdrawal>;
};

export type Subscription_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};

export type SubscriptionAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountNftSlotArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountNftSlotsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type SubscriptionAccountTokenBalanceArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountTokenBalanceDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountTokenBalanceDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceDailyData_Filter>;
};

export type SubscriptionAccountTokenBalanceWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountTokenBalanceWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalanceWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalanceWeeklyData_Filter>;
};

export type SubscriptionAccountTokenBalancesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type SubscriptionAccountUpdateArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAccountUpdatesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountUpdate_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountUpdate_Filter>;
};

export type SubscriptionAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Account_Filter>;
};

export type SubscriptionAddArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAddsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Add_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Add_Filter>;
};

export type SubscriptionAmmUpdateArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionAmmUpdatesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AmmUpdate_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AmmUpdate_Filter>;
};

export type SubscriptionBlockArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionBlocksArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Block_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Block_Filter>;
};

export type SubscriptionDataNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionDataNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DataNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<DataNft_Filter>;
};

export type SubscriptionDepositArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionDepositsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Deposit_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Deposit_Filter>;
};

export type SubscriptionExchangeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionExchangesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Exchange_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Exchange_Filter>;
};

export type SubscriptionMintNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionMintNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MintNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<MintNft_Filter>;
};

export type SubscriptionNonFungibleTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionNonFungibleTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type SubscriptionOrderbookTradeArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionOrderbookTradesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrderbookTrade_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<OrderbookTrade_Filter>;
};

export type SubscriptionPairArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionPairDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionPairDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairDailyData_Filter>;
};

export type SubscriptionPairWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionPairWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PairWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PairWeeklyData_Filter>;
};

export type SubscriptionPairsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Pair_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pair_Filter>;
};

export type SubscriptionPoolArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionPoolsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Pool_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Pool_Filter>;
};

export type SubscriptionProtocolAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionProtocolAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProtocolAccount_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ProtocolAccount_Filter>;
};

export type SubscriptionProxiesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Proxy_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Proxy_Filter>;
};

export type SubscriptionProxyArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionRemoveArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionRemovesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Remove_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Remove_Filter>;
};

export type SubscriptionSignatureVerificationArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionSignatureVerificationsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SignatureVerification_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SignatureVerification_Filter>;
};

export type SubscriptionSwapArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionSwapNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionSwapNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SwapNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SwapNft_Filter>;
};

export type SubscriptionSwapsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Swap_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Swap_Filter>;
};

export type SubscriptionTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTokenDailyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTokenDailyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDailyData_Filter>;
};

export type SubscriptionTokenWeeklyDataArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTokenWeeklyDatasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenWeeklyData_Filter>;
};

export type SubscriptionTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};

export type SubscriptionTradeNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTradeNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TradeNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TradeNft_Filter>;
};

export type SubscriptionTransactionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTransactionNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTransactionNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransactionNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TransactionNft_Filter>;
};

export type SubscriptionTransactionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transaction_Filter>;
};

export type SubscriptionTransferArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTransferNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionTransferNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransferNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TransferNft_Filter>;
};

export type SubscriptionTransfersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transfer_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Transfer_Filter>;
};

export type SubscriptionUserArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionUsersArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<User_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<User_Filter>;
};

export type SubscriptionWithdrawalArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionWithdrawalNftArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};

export type SubscriptionWithdrawalNfTsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<WithdrawalNft_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<WithdrawalNft_Filter>;
};

export type SubscriptionWithdrawalsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Withdrawal_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Withdrawal_Filter>;
};

export type Swap = Transaction & {
  __typename?: 'Swap';
  /** Account that swapped the tokens */
  account: Account;
  /** [RAW L2 DATA] Account ID of account A */
  accountIdA: Scalars['Int'];
  /** [RAW L2 DATA] Account ID of account B */
  accountIdB: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Float encoded value for fillSA represented as an Int */
  fFillSA: Scalars['Int'];
  /** [RAW L2 DATA] Float encoded value for fillSB represented as an Int */
  fFillSB: Scalars['Int'];
  /** [RAW L2 DATA] Fee paid by Account A with Token B */
  feeA: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee paid by Account B with token A */
  feeB: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee bips for order A */
  feeBipsA: Scalars['BigInt'];
  /** [RAW L2 DATA] Fee bips for order B */
  feeBipsB: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data A */
  feeBipsHiA: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data B */
  feeBipsHiB: Scalars['BigInt'];
  /** [RAW L2 DATA] Is fill amount for buy or sell for order A */
  fillAmountBorSA: Scalars['Boolean'];
  /** [RAW L2 DATA] Is fill amount for buy or sell for order B */
  fillAmountBorSB: Scalars['Boolean'];
  /** [RAW L2 DATA] Amount of token B bought by Account A */
  fillBA: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token A bought by Account B */
  fillBB: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token A sold by Account A */
  fillSA: Scalars['BigInt'];
  /** [RAW L2 DATA] Amount of token B sold by Account B */
  fillSB: Scalars['BigInt'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] Limit mask value for order A */
  limitMaskA: Scalars['BigInt'];
  /** [RAW L2 DATA] Limit mask value for order B */
  limitMaskB: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data A */
  orderDataA: Scalars['BigInt'];
  /** [RAW L2 DATA] Order data B */
  orderDataB: Scalars['BigInt'];
  /** Standardized Pair entity for this trade */
  pair: Pair;
  /** AMM Pool that facilitated the swap */
  pool: Pool;
  /** [RAW L2 DATA] Protocol fees paid by Account A */
  protocolFeeA: Scalars['BigInt'];
  /** [RAW L2 DATA] Protocol fees paid by Account B */
  protocolFeeB: Scalars['BigInt'];
  /** [RAW L2 DATA] StorageID for account A */
  storageIdA: Scalars['Int'];
  /** [RAW L2 DATA] StorageID for account B */
  storageIdB: Scalars['Int'];
  /** Token A. Supplied by Account A */
  tokenA: Token;
  /** Price for 1 unit of token A for this trade. Denominated in token B */
  tokenAPrice: Scalars['BigInt'];
  /** Token B. Supplied by Account B */
  tokenB: Token;
  /** Price for 1 unit of token B for this trade. Denominated in token A */
  tokenBPrice: Scalars['BigInt'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of token bought by account A. Should coincide with tokenIDBS */
  tokenIDAB: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token sold by account A */
  tokenIDAS: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token bought by account B. Should coincide with tokenIDAS */
  tokenIDBB: Scalars['Int'];
  /** [RAW L2 DATA] Token ID of token sold by account B */
  tokenIDBS: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type SwapAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type SwapTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type SwapNft = Transaction &
  TransactionNft & {
    __typename?: 'SwapNFT';
    /** Account entity A */
    accountA: Account;
    /** Account entity B */
    accountB: Account;
    /** [RAW L2 DATA] Account ID of account A */
    accountIdA: Scalars['Int'];
    /** [RAW L2 DATA] Account ID of account B */
    accountIdB: Scalars['Int'];
    accounts?: Maybe<Array<Account>>;
    block: Block;
    data: Scalars['String'];
    /** [RAW L2 DATA] Float encoded value for fillSA represented as an Int */
    fFillSA: Scalars['Int'];
    /** [RAW L2 DATA] Float encoded value for fillSB represented as an Int */
    fFillSB: Scalars['Int'];
    /** [RAW L2 DATA] Fee bips for order A */
    feeBipsA: Scalars['BigInt'];
    /** [RAW L2 DATA] Fee bips for order B */
    feeBipsB: Scalars['BigInt'];
    /** [RAW L2 DATA] Order data A */
    feeBipsHiA: Scalars['BigInt'];
    /** [RAW L2 DATA] Order data B */
    feeBipsHiB: Scalars['BigInt'];
    /** [RAW L2 DATA] Is fill amount for buy or sell for order A */
    fillAmountBorSA: Scalars['Boolean'];
    /** [RAW L2 DATA] Is fill amount for buy or sell for order B */
    fillAmountBorSB: Scalars['Boolean'];
    /** [RAW L2 DATA] Amount of token B bought by Account A */
    fillBA: Scalars['BigInt'];
    /** [RAW L2 DATA] Amount of token A bought by Account B */
    fillBB: Scalars['BigInt'];
    /** [RAW L2 DATA] Amount of token A sold by Account A */
    fillSA: Scalars['BigInt'];
    /** [RAW L2 DATA] Amount of token B sold by Account B */
    fillSB: Scalars['BigInt'];
    id: Scalars['ID'];
    /** ID represented as a BigDecimal for sorting purposes */
    internalID: Scalars['BigDecimal'];
    /** [RAW L2 DATA] Limit mask value for order A */
    limitMaskA: Scalars['BigInt'];
    /** [RAW L2 DATA] Limit mask value for order B */
    limitMaskB: Scalars['BigInt'];
    nfts: Array<NonFungibleToken>;
    /** [RAW L2 DATA] Order data A */
    orderDataA: Scalars['BigInt'];
    /** [RAW L2 DATA] Order data B */
    orderDataB: Scalars['BigInt'];
    /** Target slot of NFT B for Account A. */
    slotABuyer: AccountNftSlot;
    /** Original slot of NFT A for Account A. */
    slotASeller: AccountNftSlot;
    /** Target slot of NFT A for Account B. */
    slotBBuyer: AccountNftSlot;
    /** Original slot of NFT B for Account B. */
    slotBSeller: AccountNftSlot;
    slots: Array<AccountNftSlot>;
    /** [RAW L2 DATA] StorageID for account A */
    storageIdA: Scalars['Int'];
    /** [RAW L2 DATA] StorageID for account B */
    storageIdB: Scalars['Int'];
    tokenBalances?: Maybe<Array<AccountTokenBalance>>;
    /** [RAW L2 DATA] Token ID of token bought by account A. Should coincide with tokenIDBS */
    tokenIDAB: Scalars['Int'];
    /** [RAW L2 DATA] Token ID of token sold by account A */
    tokenIDAS: Scalars['Int'];
    /** [RAW L2 DATA] Token ID of token bought by account B. Should coincide with tokenIDAS */
    tokenIDBB: Scalars['Int'];
    /** [RAW L2 DATA] Token ID of token sold by account B */
    tokenIDBS: Scalars['Int'];
    /** Explicit copy of __typename to make it usable when filtering */
    typename: TransactionType;
  };

export type SwapNftAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type SwapNftNftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type SwapNftSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type SwapNftTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type SwapNft_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountA?: InputMaybe<Scalars['String']>;
  accountA_?: InputMaybe<Account_Filter>;
  accountA_contains?: InputMaybe<Scalars['String']>;
  accountA_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_ends_with?: InputMaybe<Scalars['String']>;
  accountA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_gt?: InputMaybe<Scalars['String']>;
  accountA_gte?: InputMaybe<Scalars['String']>;
  accountA_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_lt?: InputMaybe<Scalars['String']>;
  accountA_lte?: InputMaybe<Scalars['String']>;
  accountA_not?: InputMaybe<Scalars['String']>;
  accountA_not_contains?: InputMaybe<Scalars['String']>;
  accountA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with?: InputMaybe<Scalars['String']>;
  accountA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountA_not_starts_with?: InputMaybe<Scalars['String']>;
  accountA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountA_starts_with?: InputMaybe<Scalars['String']>;
  accountA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB?: InputMaybe<Scalars['String']>;
  accountB_?: InputMaybe<Account_Filter>;
  accountB_contains?: InputMaybe<Scalars['String']>;
  accountB_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_ends_with?: InputMaybe<Scalars['String']>;
  accountB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_gt?: InputMaybe<Scalars['String']>;
  accountB_gte?: InputMaybe<Scalars['String']>;
  accountB_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_lt?: InputMaybe<Scalars['String']>;
  accountB_lte?: InputMaybe<Scalars['String']>;
  accountB_not?: InputMaybe<Scalars['String']>;
  accountB_not_contains?: InputMaybe<Scalars['String']>;
  accountB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with?: InputMaybe<Scalars['String']>;
  accountB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountB_not_starts_with?: InputMaybe<Scalars['String']>;
  accountB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountB_starts_with?: InputMaybe<Scalars['String']>;
  accountB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountIdA?: InputMaybe<Scalars['Int']>;
  accountIdA_gt?: InputMaybe<Scalars['Int']>;
  accountIdA_gte?: InputMaybe<Scalars['Int']>;
  accountIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdA_lt?: InputMaybe<Scalars['Int']>;
  accountIdA_lte?: InputMaybe<Scalars['Int']>;
  accountIdA_not?: InputMaybe<Scalars['Int']>;
  accountIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB?: InputMaybe<Scalars['Int']>;
  accountIdB_gt?: InputMaybe<Scalars['Int']>;
  accountIdB_gte?: InputMaybe<Scalars['Int']>;
  accountIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB_lt?: InputMaybe<Scalars['Int']>;
  accountIdB_lte?: InputMaybe<Scalars['Int']>;
  accountIdB_not?: InputMaybe<Scalars['Int']>;
  accountIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fFillSA?: InputMaybe<Scalars['Int']>;
  fFillSA_gt?: InputMaybe<Scalars['Int']>;
  fFillSA_gte?: InputMaybe<Scalars['Int']>;
  fFillSA_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSA_lt?: InputMaybe<Scalars['Int']>;
  fFillSA_lte?: InputMaybe<Scalars['Int']>;
  fFillSA_not?: InputMaybe<Scalars['Int']>;
  fFillSA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB?: InputMaybe<Scalars['Int']>;
  fFillSB_gt?: InputMaybe<Scalars['Int']>;
  fFillSB_gte?: InputMaybe<Scalars['Int']>;
  fFillSB_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB_lt?: InputMaybe<Scalars['Int']>;
  fFillSB_lte?: InputMaybe<Scalars['Int']>;
  fFillSB_not?: InputMaybe<Scalars['Int']>;
  fFillSB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeBipsA?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillAmountBorSA?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSA_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillBA?: InputMaybe<Scalars['BigInt']>;
  fillBA_gt?: InputMaybe<Scalars['BigInt']>;
  fillBA_gte?: InputMaybe<Scalars['BigInt']>;
  fillBA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBA_lt?: InputMaybe<Scalars['BigInt']>;
  fillBA_lte?: InputMaybe<Scalars['BigInt']>;
  fillBA_not?: InputMaybe<Scalars['BigInt']>;
  fillBA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB?: InputMaybe<Scalars['BigInt']>;
  fillBB_gt?: InputMaybe<Scalars['BigInt']>;
  fillBB_gte?: InputMaybe<Scalars['BigInt']>;
  fillBB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB_lt?: InputMaybe<Scalars['BigInt']>;
  fillBB_lte?: InputMaybe<Scalars['BigInt']>;
  fillBB_not?: InputMaybe<Scalars['BigInt']>;
  fillBB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA?: InputMaybe<Scalars['BigInt']>;
  fillSA_gt?: InputMaybe<Scalars['BigInt']>;
  fillSA_gte?: InputMaybe<Scalars['BigInt']>;
  fillSA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA_lt?: InputMaybe<Scalars['BigInt']>;
  fillSA_lte?: InputMaybe<Scalars['BigInt']>;
  fillSA_not?: InputMaybe<Scalars['BigInt']>;
  fillSA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB?: InputMaybe<Scalars['BigInt']>;
  fillSB_gt?: InputMaybe<Scalars['BigInt']>;
  fillSB_gte?: InputMaybe<Scalars['BigInt']>;
  fillSB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB_lt?: InputMaybe<Scalars['BigInt']>;
  fillSB_lte?: InputMaybe<Scalars['BigInt']>;
  fillSB_not?: InputMaybe<Scalars['BigInt']>;
  fillSB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  limitMaskA?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskA_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nfts?: InputMaybe<Array<Scalars['String']>>;
  nfts_?: InputMaybe<NonFungibleToken_Filter>;
  nfts_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  nfts_not?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  orderDataA?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataA_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  slotABuyer?: InputMaybe<Scalars['String']>;
  slotABuyer_?: InputMaybe<AccountNftSlot_Filter>;
  slotABuyer_contains?: InputMaybe<Scalars['String']>;
  slotABuyer_contains_nocase?: InputMaybe<Scalars['String']>;
  slotABuyer_ends_with?: InputMaybe<Scalars['String']>;
  slotABuyer_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotABuyer_gt?: InputMaybe<Scalars['String']>;
  slotABuyer_gte?: InputMaybe<Scalars['String']>;
  slotABuyer_in?: InputMaybe<Array<Scalars['String']>>;
  slotABuyer_lt?: InputMaybe<Scalars['String']>;
  slotABuyer_lte?: InputMaybe<Scalars['String']>;
  slotABuyer_not?: InputMaybe<Scalars['String']>;
  slotABuyer_not_contains?: InputMaybe<Scalars['String']>;
  slotABuyer_not_contains_nocase?: InputMaybe<Scalars['String']>;
  slotABuyer_not_ends_with?: InputMaybe<Scalars['String']>;
  slotABuyer_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotABuyer_not_in?: InputMaybe<Array<Scalars['String']>>;
  slotABuyer_not_starts_with?: InputMaybe<Scalars['String']>;
  slotABuyer_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotABuyer_starts_with?: InputMaybe<Scalars['String']>;
  slotABuyer_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotASeller?: InputMaybe<Scalars['String']>;
  slotASeller_?: InputMaybe<AccountNftSlot_Filter>;
  slotASeller_contains?: InputMaybe<Scalars['String']>;
  slotASeller_contains_nocase?: InputMaybe<Scalars['String']>;
  slotASeller_ends_with?: InputMaybe<Scalars['String']>;
  slotASeller_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotASeller_gt?: InputMaybe<Scalars['String']>;
  slotASeller_gte?: InputMaybe<Scalars['String']>;
  slotASeller_in?: InputMaybe<Array<Scalars['String']>>;
  slotASeller_lt?: InputMaybe<Scalars['String']>;
  slotASeller_lte?: InputMaybe<Scalars['String']>;
  slotASeller_not?: InputMaybe<Scalars['String']>;
  slotASeller_not_contains?: InputMaybe<Scalars['String']>;
  slotASeller_not_contains_nocase?: InputMaybe<Scalars['String']>;
  slotASeller_not_ends_with?: InputMaybe<Scalars['String']>;
  slotASeller_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotASeller_not_in?: InputMaybe<Array<Scalars['String']>>;
  slotASeller_not_starts_with?: InputMaybe<Scalars['String']>;
  slotASeller_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotASeller_starts_with?: InputMaybe<Scalars['String']>;
  slotASeller_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotBBuyer?: InputMaybe<Scalars['String']>;
  slotBBuyer_?: InputMaybe<AccountNftSlot_Filter>;
  slotBBuyer_contains?: InputMaybe<Scalars['String']>;
  slotBBuyer_contains_nocase?: InputMaybe<Scalars['String']>;
  slotBBuyer_ends_with?: InputMaybe<Scalars['String']>;
  slotBBuyer_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotBBuyer_gt?: InputMaybe<Scalars['String']>;
  slotBBuyer_gte?: InputMaybe<Scalars['String']>;
  slotBBuyer_in?: InputMaybe<Array<Scalars['String']>>;
  slotBBuyer_lt?: InputMaybe<Scalars['String']>;
  slotBBuyer_lte?: InputMaybe<Scalars['String']>;
  slotBBuyer_not?: InputMaybe<Scalars['String']>;
  slotBBuyer_not_contains?: InputMaybe<Scalars['String']>;
  slotBBuyer_not_contains_nocase?: InputMaybe<Scalars['String']>;
  slotBBuyer_not_ends_with?: InputMaybe<Scalars['String']>;
  slotBBuyer_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotBBuyer_not_in?: InputMaybe<Array<Scalars['String']>>;
  slotBBuyer_not_starts_with?: InputMaybe<Scalars['String']>;
  slotBBuyer_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotBBuyer_starts_with?: InputMaybe<Scalars['String']>;
  slotBBuyer_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotBSeller?: InputMaybe<Scalars['String']>;
  slotBSeller_?: InputMaybe<AccountNftSlot_Filter>;
  slotBSeller_contains?: InputMaybe<Scalars['String']>;
  slotBSeller_contains_nocase?: InputMaybe<Scalars['String']>;
  slotBSeller_ends_with?: InputMaybe<Scalars['String']>;
  slotBSeller_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotBSeller_gt?: InputMaybe<Scalars['String']>;
  slotBSeller_gte?: InputMaybe<Scalars['String']>;
  slotBSeller_in?: InputMaybe<Array<Scalars['String']>>;
  slotBSeller_lt?: InputMaybe<Scalars['String']>;
  slotBSeller_lte?: InputMaybe<Scalars['String']>;
  slotBSeller_not?: InputMaybe<Scalars['String']>;
  slotBSeller_not_contains?: InputMaybe<Scalars['String']>;
  slotBSeller_not_contains_nocase?: InputMaybe<Scalars['String']>;
  slotBSeller_not_ends_with?: InputMaybe<Scalars['String']>;
  slotBSeller_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotBSeller_not_in?: InputMaybe<Array<Scalars['String']>>;
  slotBSeller_not_starts_with?: InputMaybe<Scalars['String']>;
  slotBSeller_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotBSeller_starts_with?: InputMaybe<Scalars['String']>;
  slotBSeller_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slots?: InputMaybe<Array<Scalars['String']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  slots_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots_not?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  storageIdA?: InputMaybe<Scalars['Int']>;
  storageIdA_gt?: InputMaybe<Scalars['Int']>;
  storageIdA_gte?: InputMaybe<Scalars['Int']>;
  storageIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdA_lt?: InputMaybe<Scalars['Int']>;
  storageIdA_lte?: InputMaybe<Scalars['Int']>;
  storageIdA_not?: InputMaybe<Scalars['Int']>;
  storageIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB?: InputMaybe<Scalars['Int']>;
  storageIdB_gt?: InputMaybe<Scalars['Int']>;
  storageIdB_gte?: InputMaybe<Scalars['Int']>;
  storageIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB_lt?: InputMaybe<Scalars['Int']>;
  storageIdB_lte?: InputMaybe<Scalars['Int']>;
  storageIdB_not?: InputMaybe<Scalars['Int']>;
  storageIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenIDAB?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum SwapNft_OrderBy {
  AccountA = 'accountA',
  AccountB = 'accountB',
  AccountIdA = 'accountIdA',
  AccountIdB = 'accountIdB',
  Accounts = 'accounts',
  Block = 'block',
  Data = 'data',
  FFillSa = 'fFillSA',
  FFillSb = 'fFillSB',
  FeeBipsA = 'feeBipsA',
  FeeBipsB = 'feeBipsB',
  FeeBipsHiA = 'feeBipsHiA',
  FeeBipsHiB = 'feeBipsHiB',
  FillAmountBorSa = 'fillAmountBorSA',
  FillAmountBorSb = 'fillAmountBorSB',
  FillBa = 'fillBA',
  FillBb = 'fillBB',
  FillSa = 'fillSA',
  FillSb = 'fillSB',
  Id = 'id',
  InternalId = 'internalID',
  LimitMaskA = 'limitMaskA',
  LimitMaskB = 'limitMaskB',
  Nfts = 'nfts',
  OrderDataA = 'orderDataA',
  OrderDataB = 'orderDataB',
  SlotABuyer = 'slotABuyer',
  SlotASeller = 'slotASeller',
  SlotBBuyer = 'slotBBuyer',
  SlotBSeller = 'slotBSeller',
  Slots = 'slots',
  StorageIdA = 'storageIdA',
  StorageIdB = 'storageIdB',
  TokenBalances = 'tokenBalances',
  TokenIdab = 'tokenIDAB',
  TokenIdas = 'tokenIDAS',
  TokenIdbb = 'tokenIDBB',
  TokenIdbs = 'tokenIDBS',
  Typename = 'typename',
}

export type Swap_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountIdA?: InputMaybe<Scalars['Int']>;
  accountIdA_gt?: InputMaybe<Scalars['Int']>;
  accountIdA_gte?: InputMaybe<Scalars['Int']>;
  accountIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdA_lt?: InputMaybe<Scalars['Int']>;
  accountIdA_lte?: InputMaybe<Scalars['Int']>;
  accountIdA_not?: InputMaybe<Scalars['Int']>;
  accountIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB?: InputMaybe<Scalars['Int']>;
  accountIdB_gt?: InputMaybe<Scalars['Int']>;
  accountIdB_gte?: InputMaybe<Scalars['Int']>;
  accountIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB_lt?: InputMaybe<Scalars['Int']>;
  accountIdB_lte?: InputMaybe<Scalars['Int']>;
  accountIdB_not?: InputMaybe<Scalars['Int']>;
  accountIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fFillSA?: InputMaybe<Scalars['Int']>;
  fFillSA_gt?: InputMaybe<Scalars['Int']>;
  fFillSA_gte?: InputMaybe<Scalars['Int']>;
  fFillSA_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSA_lt?: InputMaybe<Scalars['Int']>;
  fFillSA_lte?: InputMaybe<Scalars['Int']>;
  fFillSA_not?: InputMaybe<Scalars['Int']>;
  fFillSA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB?: InputMaybe<Scalars['Int']>;
  fFillSB_gt?: InputMaybe<Scalars['Int']>;
  fFillSB_gte?: InputMaybe<Scalars['Int']>;
  fFillSB_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB_lt?: InputMaybe<Scalars['Int']>;
  fFillSB_lte?: InputMaybe<Scalars['Int']>;
  fFillSB_not?: InputMaybe<Scalars['Int']>;
  fFillSB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeA?: InputMaybe<Scalars['BigInt']>;
  feeA_gt?: InputMaybe<Scalars['BigInt']>;
  feeA_gte?: InputMaybe<Scalars['BigInt']>;
  feeA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeA_lt?: InputMaybe<Scalars['BigInt']>;
  feeA_lte?: InputMaybe<Scalars['BigInt']>;
  feeA_not?: InputMaybe<Scalars['BigInt']>;
  feeA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeB?: InputMaybe<Scalars['BigInt']>;
  feeB_gt?: InputMaybe<Scalars['BigInt']>;
  feeB_gte?: InputMaybe<Scalars['BigInt']>;
  feeB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeB_lt?: InputMaybe<Scalars['BigInt']>;
  feeB_lte?: InputMaybe<Scalars['BigInt']>;
  feeB_not?: InputMaybe<Scalars['BigInt']>;
  feeB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillAmountBorSA?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSA_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillBA?: InputMaybe<Scalars['BigInt']>;
  fillBA_gt?: InputMaybe<Scalars['BigInt']>;
  fillBA_gte?: InputMaybe<Scalars['BigInt']>;
  fillBA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBA_lt?: InputMaybe<Scalars['BigInt']>;
  fillBA_lte?: InputMaybe<Scalars['BigInt']>;
  fillBA_not?: InputMaybe<Scalars['BigInt']>;
  fillBA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB?: InputMaybe<Scalars['BigInt']>;
  fillBB_gt?: InputMaybe<Scalars['BigInt']>;
  fillBB_gte?: InputMaybe<Scalars['BigInt']>;
  fillBB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB_lt?: InputMaybe<Scalars['BigInt']>;
  fillBB_lte?: InputMaybe<Scalars['BigInt']>;
  fillBB_not?: InputMaybe<Scalars['BigInt']>;
  fillBB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA?: InputMaybe<Scalars['BigInt']>;
  fillSA_gt?: InputMaybe<Scalars['BigInt']>;
  fillSA_gte?: InputMaybe<Scalars['BigInt']>;
  fillSA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA_lt?: InputMaybe<Scalars['BigInt']>;
  fillSA_lte?: InputMaybe<Scalars['BigInt']>;
  fillSA_not?: InputMaybe<Scalars['BigInt']>;
  fillSA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB?: InputMaybe<Scalars['BigInt']>;
  fillSB_gt?: InputMaybe<Scalars['BigInt']>;
  fillSB_gte?: InputMaybe<Scalars['BigInt']>;
  fillSB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB_lt?: InputMaybe<Scalars['BigInt']>;
  fillSB_lte?: InputMaybe<Scalars['BigInt']>;
  fillSB_not?: InputMaybe<Scalars['BigInt']>;
  fillSB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  limitMaskA?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskA_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataA?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataA_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  pair?: InputMaybe<Scalars['String']>;
  pair_?: InputMaybe<Pair_Filter>;
  pair_contains?: InputMaybe<Scalars['String']>;
  pair_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_ends_with?: InputMaybe<Scalars['String']>;
  pair_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_gt?: InputMaybe<Scalars['String']>;
  pair_gte?: InputMaybe<Scalars['String']>;
  pair_in?: InputMaybe<Array<Scalars['String']>>;
  pair_lt?: InputMaybe<Scalars['String']>;
  pair_lte?: InputMaybe<Scalars['String']>;
  pair_not?: InputMaybe<Scalars['String']>;
  pair_not_contains?: InputMaybe<Scalars['String']>;
  pair_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pair_not_ends_with?: InputMaybe<Scalars['String']>;
  pair_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pair_not_in?: InputMaybe<Array<Scalars['String']>>;
  pair_not_starts_with?: InputMaybe<Scalars['String']>;
  pair_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pair_starts_with?: InputMaybe<Scalars['String']>;
  pair_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pool?: InputMaybe<Scalars['String']>;
  pool_?: InputMaybe<Pool_Filter>;
  pool_contains?: InputMaybe<Scalars['String']>;
  pool_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_ends_with?: InputMaybe<Scalars['String']>;
  pool_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_gt?: InputMaybe<Scalars['String']>;
  pool_gte?: InputMaybe<Scalars['String']>;
  pool_in?: InputMaybe<Array<Scalars['String']>>;
  pool_lt?: InputMaybe<Scalars['String']>;
  pool_lte?: InputMaybe<Scalars['String']>;
  pool_not?: InputMaybe<Scalars['String']>;
  pool_not_contains?: InputMaybe<Scalars['String']>;
  pool_not_contains_nocase?: InputMaybe<Scalars['String']>;
  pool_not_ends_with?: InputMaybe<Scalars['String']>;
  pool_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  pool_not_in?: InputMaybe<Array<Scalars['String']>>;
  pool_not_starts_with?: InputMaybe<Scalars['String']>;
  pool_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  pool_starts_with?: InputMaybe<Scalars['String']>;
  pool_starts_with_nocase?: InputMaybe<Scalars['String']>;
  protocolFeeA?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeA_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeB?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeB_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  storageIdA?: InputMaybe<Scalars['Int']>;
  storageIdA_gt?: InputMaybe<Scalars['Int']>;
  storageIdA_gte?: InputMaybe<Scalars['Int']>;
  storageIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdA_lt?: InputMaybe<Scalars['Int']>;
  storageIdA_lte?: InputMaybe<Scalars['Int']>;
  storageIdA_not?: InputMaybe<Scalars['Int']>;
  storageIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB?: InputMaybe<Scalars['Int']>;
  storageIdB_gt?: InputMaybe<Scalars['Int']>;
  storageIdB_gte?: InputMaybe<Scalars['Int']>;
  storageIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB_lt?: InputMaybe<Scalars['Int']>;
  storageIdB_lte?: InputMaybe<Scalars['Int']>;
  storageIdB_not?: InputMaybe<Scalars['Int']>;
  storageIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenA?: InputMaybe<Scalars['String']>;
  tokenAPrice?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_gt?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_gte?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenAPrice_lt?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_lte?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_not?: InputMaybe<Scalars['BigInt']>;
  tokenAPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenA_?: InputMaybe<Token_Filter>;
  tokenA_contains?: InputMaybe<Scalars['String']>;
  tokenA_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_gt?: InputMaybe<Scalars['String']>;
  tokenA_gte?: InputMaybe<Scalars['String']>;
  tokenA_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_lt?: InputMaybe<Scalars['String']>;
  tokenA_lte?: InputMaybe<Scalars['String']>;
  tokenA_not?: InputMaybe<Scalars['String']>;
  tokenA_not_contains?: InputMaybe<Scalars['String']>;
  tokenA_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenA_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenA_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenA_starts_with?: InputMaybe<Scalars['String']>;
  tokenA_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB?: InputMaybe<Scalars['String']>;
  tokenBPrice?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_gt?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_gte?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenBPrice_lt?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_lte?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_not?: InputMaybe<Scalars['BigInt']>;
  tokenBPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenB_?: InputMaybe<Token_Filter>;
  tokenB_contains?: InputMaybe<Scalars['String']>;
  tokenB_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_gt?: InputMaybe<Scalars['String']>;
  tokenB_gte?: InputMaybe<Scalars['String']>;
  tokenB_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_lt?: InputMaybe<Scalars['String']>;
  tokenB_lte?: InputMaybe<Scalars['String']>;
  tokenB_not?: InputMaybe<Scalars['String']>;
  tokenB_not_contains?: InputMaybe<Scalars['String']>;
  tokenB_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenB_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenB_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenB_starts_with?: InputMaybe<Scalars['String']>;
  tokenB_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenIDAB?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Swap_OrderBy {
  Account = 'account',
  AccountIdA = 'accountIdA',
  AccountIdB = 'accountIdB',
  Accounts = 'accounts',
  Block = 'block',
  Data = 'data',
  FFillSa = 'fFillSA',
  FFillSb = 'fFillSB',
  FeeA = 'feeA',
  FeeB = 'feeB',
  FeeBipsA = 'feeBipsA',
  FeeBipsB = 'feeBipsB',
  FeeBipsHiA = 'feeBipsHiA',
  FeeBipsHiB = 'feeBipsHiB',
  FillAmountBorSa = 'fillAmountBorSA',
  FillAmountBorSb = 'fillAmountBorSB',
  FillBa = 'fillBA',
  FillBb = 'fillBB',
  FillSa = 'fillSA',
  FillSb = 'fillSB',
  Id = 'id',
  InternalId = 'internalID',
  LimitMaskA = 'limitMaskA',
  LimitMaskB = 'limitMaskB',
  OrderDataA = 'orderDataA',
  OrderDataB = 'orderDataB',
  Pair = 'pair',
  Pool = 'pool',
  ProtocolFeeA = 'protocolFeeA',
  ProtocolFeeB = 'protocolFeeB',
  StorageIdA = 'storageIdA',
  StorageIdB = 'storageIdB',
  TokenA = 'tokenA',
  TokenAPrice = 'tokenAPrice',
  TokenB = 'tokenB',
  TokenBPrice = 'tokenBPrice',
  TokenBalances = 'tokenBalances',
  TokenIdab = 'tokenIDAB',
  TokenIdas = 'tokenIDAS',
  TokenIdbb = 'tokenIDBB',
  TokenIdbs = 'tokenIDBS',
  Typename = 'typename',
}

export type Token = {
  __typename?: 'Token';
  /** Address of the token within the Ethereum network */
  address: Scalars['Bytes'];
  dailyEntities: Array<TokenDailyData>;
  decimals: Scalars['Int'];
  /** Exchange active when the token was registered */
  exchange: Exchange;
  /** Internal ID of the token within Loopring */
  id: Scalars['ID'];
  /** Internal ID of the token within loopring expressed as a number for ordering */
  internalID: Scalars['BigInt'];
  name: Scalars['String'];
  symbol: Scalars['String'];
  /** Total traded volume for this token across all token pairs. Denominated in it's own currency */
  tradedVolume: Scalars['BigInt'];
  /** Total traded volume for this token across all token pairs. Denominated in it's own currency */
  tradedVolumeOrderbook: Scalars['BigInt'];
  /** Total traded volume for this token across all token pairs. Denominated in it's own currency */
  tradedVolumeSwap: Scalars['BigInt'];
  weeklyEntities: Array<TokenWeeklyData>;
};

export type TokenDailyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDailyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenDailyData_Filter>;
};

export type TokenWeeklyEntitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenWeeklyData_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenWeeklyData_Filter>;
};

export type TokenDailyData = {
  __typename?: 'TokenDailyData';
  /** Timestamp of the end of the day. Timezone -> UTC */
  dayEnd: Scalars['BigInt'];
  /** Day number is the amount of days since the start block of Loopring 3.6 (block 11149814) */
  dayNumber: Scalars['Int'];
  /** Timestamp of the start of the day. Timezone -> UTC */
  dayStart: Scalars['BigInt'];
  /** The ID follows this pattern: <TOKEN ID>-<DAY NUMBER>. */
  id: Scalars['ID'];
  token: Token;
  /** Volume traded for the token. Includes both Swaps and Orderbook trades */
  tradedVolume: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Orderbook trades */
  tradedVolumeOrderbook: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Swaps */
  tradedVolumeSwap: Scalars['BigInt'];
};

export type TokenDailyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  dayEnd?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_gte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayEnd_lt?: InputMaybe<Scalars['BigInt']>;
  dayEnd_lte?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not?: InputMaybe<Scalars['BigInt']>;
  dayEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayNumber?: InputMaybe<Scalars['Int']>;
  dayNumber_gt?: InputMaybe<Scalars['Int']>;
  dayNumber_gte?: InputMaybe<Scalars['Int']>;
  dayNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  dayNumber_lt?: InputMaybe<Scalars['Int']>;
  dayNumber_lte?: InputMaybe<Scalars['Int']>;
  dayNumber_not?: InputMaybe<Scalars['Int']>;
  dayNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  dayStart?: InputMaybe<Scalars['BigInt']>;
  dayStart_gt?: InputMaybe<Scalars['BigInt']>;
  dayStart_gte?: InputMaybe<Scalars['BigInt']>;
  dayStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  dayStart_lt?: InputMaybe<Scalars['BigInt']>;
  dayStart_lte?: InputMaybe<Scalars['BigInt']>;
  dayStart_not?: InputMaybe<Scalars['BigInt']>;
  dayStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolume?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeOrderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum TokenDailyData_OrderBy {
  DayEnd = 'dayEnd',
  DayNumber = 'dayNumber',
  DayStart = 'dayStart',
  Id = 'id',
  Token = 'token',
  TradedVolume = 'tradedVolume',
  TradedVolumeOrderbook = 'tradedVolumeOrderbook',
  TradedVolumeSwap = 'tradedVolumeSwap',
}

export type TokenWeeklyData = {
  __typename?: 'TokenWeeklyData';
  /** The ID follows this pattern: <TOKEN ID>-<WEEK NUMBER>. */
  id: Scalars['ID'];
  token: Token;
  /** Volume traded for the token. Includes both Swaps and Orderbook trades */
  tradedVolume: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Orderbook trades */
  tradedVolumeOrderbook: Scalars['BigInt'];
  /** Volume traded for the token exclusively on Swaps */
  tradedVolumeSwap: Scalars['BigInt'];
  /** Timestamp of the end of the week. Timezone -> UTC */
  weekEnd: Scalars['BigInt'];
  /** Week number is the amount of weeks since the start block of Loopring 3.6 (block 11149814) */
  weekNumber: Scalars['Int'];
  /** Timestamp of the start of the week. Timezone -> UTC */
  weekStart: Scalars['BigInt'];
};

export type TokenWeeklyData_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolume?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeOrderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_gte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekEnd_lt?: InputMaybe<Scalars['BigInt']>;
  weekEnd_lte?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not?: InputMaybe<Scalars['BigInt']>;
  weekEnd_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekNumber?: InputMaybe<Scalars['Int']>;
  weekNumber_gt?: InputMaybe<Scalars['Int']>;
  weekNumber_gte?: InputMaybe<Scalars['Int']>;
  weekNumber_in?: InputMaybe<Array<Scalars['Int']>>;
  weekNumber_lt?: InputMaybe<Scalars['Int']>;
  weekNumber_lte?: InputMaybe<Scalars['Int']>;
  weekNumber_not?: InputMaybe<Scalars['Int']>;
  weekNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;
  weekStart?: InputMaybe<Scalars['BigInt']>;
  weekStart_gt?: InputMaybe<Scalars['BigInt']>;
  weekStart_gte?: InputMaybe<Scalars['BigInt']>;
  weekStart_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weekStart_lt?: InputMaybe<Scalars['BigInt']>;
  weekStart_lte?: InputMaybe<Scalars['BigInt']>;
  weekStart_not?: InputMaybe<Scalars['BigInt']>;
  weekStart_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum TokenWeeklyData_OrderBy {
  Id = 'id',
  Token = 'token',
  TradedVolume = 'tradedVolume',
  TradedVolumeOrderbook = 'tradedVolumeOrderbook',
  TradedVolumeSwap = 'tradedVolumeSwap',
  WeekEnd = 'weekEnd',
  WeekNumber = 'weekNumber',
  WeekStart = 'weekStart',
}

export type Token_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  dailyEntities_?: InputMaybe<TokenDailyData_Filter>;
  decimals?: InputMaybe<Scalars['Int']>;
  decimals_gt?: InputMaybe<Scalars['Int']>;
  decimals_gte?: InputMaybe<Scalars['Int']>;
  decimals_in?: InputMaybe<Array<Scalars['Int']>>;
  decimals_lt?: InputMaybe<Scalars['Int']>;
  decimals_lte?: InputMaybe<Scalars['Int']>;
  decimals_not?: InputMaybe<Scalars['Int']>;
  decimals_not_in?: InputMaybe<Array<Scalars['Int']>>;
  exchange?: InputMaybe<Scalars['String']>;
  exchange_?: InputMaybe<Exchange_Filter>;
  exchange_contains?: InputMaybe<Scalars['String']>;
  exchange_contains_nocase?: InputMaybe<Scalars['String']>;
  exchange_ends_with?: InputMaybe<Scalars['String']>;
  exchange_ends_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_gt?: InputMaybe<Scalars['String']>;
  exchange_gte?: InputMaybe<Scalars['String']>;
  exchange_in?: InputMaybe<Array<Scalars['String']>>;
  exchange_lt?: InputMaybe<Scalars['String']>;
  exchange_lte?: InputMaybe<Scalars['String']>;
  exchange_not?: InputMaybe<Scalars['String']>;
  exchange_not_contains?: InputMaybe<Scalars['String']>;
  exchange_not_contains_nocase?: InputMaybe<Scalars['String']>;
  exchange_not_ends_with?: InputMaybe<Scalars['String']>;
  exchange_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_not_in?: InputMaybe<Array<Scalars['String']>>;
  exchange_not_starts_with?: InputMaybe<Scalars['String']>;
  exchange_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  exchange_starts_with?: InputMaybe<Scalars['String']>;
  exchange_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  symbol?: InputMaybe<Scalars['String']>;
  symbol_contains?: InputMaybe<Scalars['String']>;
  symbol_contains_nocase?: InputMaybe<Scalars['String']>;
  symbol_ends_with?: InputMaybe<Scalars['String']>;
  symbol_ends_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_gt?: InputMaybe<Scalars['String']>;
  symbol_gte?: InputMaybe<Scalars['String']>;
  symbol_in?: InputMaybe<Array<Scalars['String']>>;
  symbol_lt?: InputMaybe<Scalars['String']>;
  symbol_lte?: InputMaybe<Scalars['String']>;
  symbol_not?: InputMaybe<Scalars['String']>;
  symbol_not_contains?: InputMaybe<Scalars['String']>;
  symbol_not_contains_nocase?: InputMaybe<Scalars['String']>;
  symbol_not_ends_with?: InputMaybe<Scalars['String']>;
  symbol_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_not_in?: InputMaybe<Array<Scalars['String']>>;
  symbol_not_starts_with?: InputMaybe<Scalars['String']>;
  symbol_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_starts_with?: InputMaybe<Scalars['String']>;
  symbol_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tradedVolume?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeOrderbook_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeOrderbook_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolumeSwap_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolumeSwap_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_gt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_gte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tradedVolume_lt?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_lte?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not?: InputMaybe<Scalars['BigInt']>;
  tradedVolume_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  weeklyEntities_?: InputMaybe<TokenWeeklyData_Filter>;
};

export enum Token_OrderBy {
  Address = 'address',
  DailyEntities = 'dailyEntities',
  Decimals = 'decimals',
  Exchange = 'exchange',
  Id = 'id',
  InternalId = 'internalID',
  Name = 'name',
  Symbol = 'symbol',
  TradedVolume = 'tradedVolume',
  TradedVolumeOrderbook = 'tradedVolumeOrderbook',
  TradedVolumeSwap = 'tradedVolumeSwap',
  WeeklyEntities = 'weeklyEntities',
}

export type TradeNft = Transaction &
  TransactionNft & {
    __typename?: 'TradeNFT';
    /** Account entity that bought the NFT */
    accountBuyer: Account;
    /** [RAW L2 DATA] Account ID of account A */
    accountIdA: Scalars['Int'];
    /** [RAW L2 DATA] Account ID of account B */
    accountIdB: Scalars['Int'];
    /** Account entity that sold the NFT */
    accountSeller: Account;
    accounts?: Maybe<Array<Account>>;
    block: Block;
    data: Scalars['String'];
    /** [RAW L2 DATA] Float encoded value for fillSA represented as an Int */
    fFillSA: Scalars['Int'];
    /** [RAW L2 DATA] Float encoded value for fillSB represented as an Int */
    fFillSB: Scalars['Int'];
    /** [RAW L2 DATA] Fee bips for order A */
    feeBipsA: Scalars['BigInt'];
    /** [RAW L2 DATA] Fee bips for order B */
    feeBipsB: Scalars['BigInt'];
    /** [RAW L2 DATA] Order data A */
    feeBipsHiA: Scalars['BigInt'];
    /** [RAW L2 DATA] Order data B */
    feeBipsHiB: Scalars['BigInt'];
    /** [RAW L2 DATA] Fee paid by Account B with token A */
    feeBuyer: Scalars['BigInt'];
    /** [RAW L2 DATA] Fee paid by Account A with Token B */
    feeSeller: Scalars['BigInt'];
    /** [RAW L2 DATA] Is fill amount for buy or sell for order A */
    fillAmountBorSA: Scalars['Boolean'];
    /** [RAW L2 DATA] Is fill amount for buy or sell for order B */
    fillAmountBorSB: Scalars['Boolean'];
    /** [RAW L2 DATA] Amount of token B bought by Account A */
    fillBA: Scalars['BigInt'];
    /** [RAW L2 DATA] Amount of token A bought by Account B */
    fillBB: Scalars['BigInt'];
    /** [RAW L2 DATA] Amount of token A sold by Account A */
    fillSA: Scalars['BigInt'];
    /** [RAW L2 DATA] Amount of token B sold by Account B */
    fillSB: Scalars['BigInt'];
    id: Scalars['ID'];
    /** ID represented as a BigDecimal for sorting purposes */
    internalID: Scalars['BigDecimal'];
    /** [RAW L2 DATA] Limit mask value for order A */
    limitMaskA: Scalars['BigInt'];
    /** [RAW L2 DATA] Limit mask value for order B */
    limitMaskB: Scalars['BigInt'];
    nfts: Array<NonFungibleToken>;
    /** [RAW L2 DATA] Order data A */
    orderDataA: Scalars['BigInt'];
    /** [RAW L2 DATA] Order data B */
    orderDataB: Scalars['BigInt'];
    /** [RAW L2 DATA] Protocol fees paid by Account B */
    protocolFeeBuyer: Scalars['BigInt'];
    /** [RAW L2 DATA] Protocol fees paid by Account A */
    protocolFeeSeller: Scalars['BigInt'];
    /** Price paid for the NFT during this trade. Expressed as a BigInt. Denominated in units of token */
    realizedNFTPrice: Scalars['BigInt'];
    /** Target slot of the NFT being traded. Represents the slot where the NFT is stored once transferred to the buyer */
    slotBuyer: AccountNftSlot;
    /** Original slot of the NFT being traded. Represents the slot where the NFT was stored for the seller */
    slotSeller: AccountNftSlot;
    slots: Array<AccountNftSlot>;
    /** [RAW L2 DATA] StorageID for account A */
    storageIdA: Scalars['Int'];
    /** [RAW L2 DATA] StorageID for account B */
    storageIdB: Scalars['Int'];
    /** Token used to pay for the NFT and fees */
    token: Token;
    tokenBalances?: Maybe<Array<AccountTokenBalance>>;
    /** [RAW L2 DATA] Token ID of token bought by account A. Should coincide with tokenIDBS */
    tokenIDAB: Scalars['Int'];
    /** [RAW L2 DATA] Token ID of token sold by account A */
    tokenIDAS: Scalars['Int'];
    /** [RAW L2 DATA] Token ID of token bought by account B. Should coincide with tokenIDAS */
    tokenIDBB: Scalars['Int'];
    /** [RAW L2 DATA] Token ID of token sold by account B */
    tokenIDBS: Scalars['Int'];
    /** Explicit copy of __typename to make it usable when filtering */
    typename: TransactionType;
  };

export type TradeNftAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type TradeNftNftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type TradeNftSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type TradeNftTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type TradeNft_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountBuyer?: InputMaybe<Scalars['String']>;
  accountBuyer_?: InputMaybe<Account_Filter>;
  accountBuyer_contains?: InputMaybe<Scalars['String']>;
  accountBuyer_contains_nocase?: InputMaybe<Scalars['String']>;
  accountBuyer_ends_with?: InputMaybe<Scalars['String']>;
  accountBuyer_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountBuyer_gt?: InputMaybe<Scalars['String']>;
  accountBuyer_gte?: InputMaybe<Scalars['String']>;
  accountBuyer_in?: InputMaybe<Array<Scalars['String']>>;
  accountBuyer_lt?: InputMaybe<Scalars['String']>;
  accountBuyer_lte?: InputMaybe<Scalars['String']>;
  accountBuyer_not?: InputMaybe<Scalars['String']>;
  accountBuyer_not_contains?: InputMaybe<Scalars['String']>;
  accountBuyer_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountBuyer_not_ends_with?: InputMaybe<Scalars['String']>;
  accountBuyer_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountBuyer_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountBuyer_not_starts_with?: InputMaybe<Scalars['String']>;
  accountBuyer_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountBuyer_starts_with?: InputMaybe<Scalars['String']>;
  accountBuyer_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountIdA?: InputMaybe<Scalars['Int']>;
  accountIdA_gt?: InputMaybe<Scalars['Int']>;
  accountIdA_gte?: InputMaybe<Scalars['Int']>;
  accountIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdA_lt?: InputMaybe<Scalars['Int']>;
  accountIdA_lte?: InputMaybe<Scalars['Int']>;
  accountIdA_not?: InputMaybe<Scalars['Int']>;
  accountIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB?: InputMaybe<Scalars['Int']>;
  accountIdB_gt?: InputMaybe<Scalars['Int']>;
  accountIdB_gte?: InputMaybe<Scalars['Int']>;
  accountIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  accountIdB_lt?: InputMaybe<Scalars['Int']>;
  accountIdB_lte?: InputMaybe<Scalars['Int']>;
  accountIdB_not?: InputMaybe<Scalars['Int']>;
  accountIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountSeller?: InputMaybe<Scalars['String']>;
  accountSeller_?: InputMaybe<Account_Filter>;
  accountSeller_contains?: InputMaybe<Scalars['String']>;
  accountSeller_contains_nocase?: InputMaybe<Scalars['String']>;
  accountSeller_ends_with?: InputMaybe<Scalars['String']>;
  accountSeller_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountSeller_gt?: InputMaybe<Scalars['String']>;
  accountSeller_gte?: InputMaybe<Scalars['String']>;
  accountSeller_in?: InputMaybe<Array<Scalars['String']>>;
  accountSeller_lt?: InputMaybe<Scalars['String']>;
  accountSeller_lte?: InputMaybe<Scalars['String']>;
  accountSeller_not?: InputMaybe<Scalars['String']>;
  accountSeller_not_contains?: InputMaybe<Scalars['String']>;
  accountSeller_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountSeller_not_ends_with?: InputMaybe<Scalars['String']>;
  accountSeller_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountSeller_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountSeller_not_starts_with?: InputMaybe<Scalars['String']>;
  accountSeller_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountSeller_starts_with?: InputMaybe<Scalars['String']>;
  accountSeller_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fFillSA?: InputMaybe<Scalars['Int']>;
  fFillSA_gt?: InputMaybe<Scalars['Int']>;
  fFillSA_gte?: InputMaybe<Scalars['Int']>;
  fFillSA_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSA_lt?: InputMaybe<Scalars['Int']>;
  fFillSA_lte?: InputMaybe<Scalars['Int']>;
  fFillSA_not?: InputMaybe<Scalars['Int']>;
  fFillSA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB?: InputMaybe<Scalars['Int']>;
  fFillSB_gt?: InputMaybe<Scalars['Int']>;
  fFillSB_gte?: InputMaybe<Scalars['Int']>;
  fFillSB_in?: InputMaybe<Array<Scalars['Int']>>;
  fFillSB_lt?: InputMaybe<Scalars['Int']>;
  fFillSB_lte?: InputMaybe<Scalars['Int']>;
  fFillSB_not?: InputMaybe<Scalars['Int']>;
  fFillSB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeBipsA?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiA_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_gte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBipsHiB_lt?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_lte?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not?: InputMaybe<Scalars['BigInt']>;
  feeBipsHiB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBuyer?: InputMaybe<Scalars['BigInt']>;
  feeBuyer_gt?: InputMaybe<Scalars['BigInt']>;
  feeBuyer_gte?: InputMaybe<Scalars['BigInt']>;
  feeBuyer_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeBuyer_lt?: InputMaybe<Scalars['BigInt']>;
  feeBuyer_lte?: InputMaybe<Scalars['BigInt']>;
  feeBuyer_not?: InputMaybe<Scalars['BigInt']>;
  feeBuyer_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeSeller?: InputMaybe<Scalars['BigInt']>;
  feeSeller_gt?: InputMaybe<Scalars['BigInt']>;
  feeSeller_gte?: InputMaybe<Scalars['BigInt']>;
  feeSeller_in?: InputMaybe<Array<Scalars['BigInt']>>;
  feeSeller_lt?: InputMaybe<Scalars['BigInt']>;
  feeSeller_lte?: InputMaybe<Scalars['BigInt']>;
  feeSeller_not?: InputMaybe<Scalars['BigInt']>;
  feeSeller_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillAmountBorSA?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSA_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSA_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillAmountBorSB_not?: InputMaybe<Scalars['Boolean']>;
  fillAmountBorSB_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  fillBA?: InputMaybe<Scalars['BigInt']>;
  fillBA_gt?: InputMaybe<Scalars['BigInt']>;
  fillBA_gte?: InputMaybe<Scalars['BigInt']>;
  fillBA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBA_lt?: InputMaybe<Scalars['BigInt']>;
  fillBA_lte?: InputMaybe<Scalars['BigInt']>;
  fillBA_not?: InputMaybe<Scalars['BigInt']>;
  fillBA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB?: InputMaybe<Scalars['BigInt']>;
  fillBB_gt?: InputMaybe<Scalars['BigInt']>;
  fillBB_gte?: InputMaybe<Scalars['BigInt']>;
  fillBB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillBB_lt?: InputMaybe<Scalars['BigInt']>;
  fillBB_lte?: InputMaybe<Scalars['BigInt']>;
  fillBB_not?: InputMaybe<Scalars['BigInt']>;
  fillBB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA?: InputMaybe<Scalars['BigInt']>;
  fillSA_gt?: InputMaybe<Scalars['BigInt']>;
  fillSA_gte?: InputMaybe<Scalars['BigInt']>;
  fillSA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSA_lt?: InputMaybe<Scalars['BigInt']>;
  fillSA_lte?: InputMaybe<Scalars['BigInt']>;
  fillSA_not?: InputMaybe<Scalars['BigInt']>;
  fillSA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB?: InputMaybe<Scalars['BigInt']>;
  fillSB_gt?: InputMaybe<Scalars['BigInt']>;
  fillSB_gte?: InputMaybe<Scalars['BigInt']>;
  fillSB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fillSB_lt?: InputMaybe<Scalars['BigInt']>;
  fillSB_lte?: InputMaybe<Scalars['BigInt']>;
  fillSB_not?: InputMaybe<Scalars['BigInt']>;
  fillSB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  limitMaskA?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskA_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_gte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  limitMaskB_lt?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_lte?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not?: InputMaybe<Scalars['BigInt']>;
  limitMaskB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  nfts?: InputMaybe<Array<Scalars['String']>>;
  nfts_?: InputMaybe<NonFungibleToken_Filter>;
  nfts_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  nfts_not?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  orderDataA?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataA_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataA_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not?: InputMaybe<Scalars['BigInt']>;
  orderDataA_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_gte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_in?: InputMaybe<Array<Scalars['BigInt']>>;
  orderDataB_lt?: InputMaybe<Scalars['BigInt']>;
  orderDataB_lte?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not?: InputMaybe<Scalars['BigInt']>;
  orderDataB_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeBuyer?: InputMaybe<Scalars['BigInt']>;
  protocolFeeBuyer_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeBuyer_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeBuyer_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeBuyer_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeBuyer_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeBuyer_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeBuyer_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeSeller?: InputMaybe<Scalars['BigInt']>;
  protocolFeeSeller_gt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeSeller_gte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeSeller_in?: InputMaybe<Array<Scalars['BigInt']>>;
  protocolFeeSeller_lt?: InputMaybe<Scalars['BigInt']>;
  protocolFeeSeller_lte?: InputMaybe<Scalars['BigInt']>;
  protocolFeeSeller_not?: InputMaybe<Scalars['BigInt']>;
  protocolFeeSeller_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  realizedNFTPrice?: InputMaybe<Scalars['BigInt']>;
  realizedNFTPrice_gt?: InputMaybe<Scalars['BigInt']>;
  realizedNFTPrice_gte?: InputMaybe<Scalars['BigInt']>;
  realizedNFTPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  realizedNFTPrice_lt?: InputMaybe<Scalars['BigInt']>;
  realizedNFTPrice_lte?: InputMaybe<Scalars['BigInt']>;
  realizedNFTPrice_not?: InputMaybe<Scalars['BigInt']>;
  realizedNFTPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  slotBuyer?: InputMaybe<Scalars['String']>;
  slotBuyer_?: InputMaybe<AccountNftSlot_Filter>;
  slotBuyer_contains?: InputMaybe<Scalars['String']>;
  slotBuyer_contains_nocase?: InputMaybe<Scalars['String']>;
  slotBuyer_ends_with?: InputMaybe<Scalars['String']>;
  slotBuyer_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotBuyer_gt?: InputMaybe<Scalars['String']>;
  slotBuyer_gte?: InputMaybe<Scalars['String']>;
  slotBuyer_in?: InputMaybe<Array<Scalars['String']>>;
  slotBuyer_lt?: InputMaybe<Scalars['String']>;
  slotBuyer_lte?: InputMaybe<Scalars['String']>;
  slotBuyer_not?: InputMaybe<Scalars['String']>;
  slotBuyer_not_contains?: InputMaybe<Scalars['String']>;
  slotBuyer_not_contains_nocase?: InputMaybe<Scalars['String']>;
  slotBuyer_not_ends_with?: InputMaybe<Scalars['String']>;
  slotBuyer_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotBuyer_not_in?: InputMaybe<Array<Scalars['String']>>;
  slotBuyer_not_starts_with?: InputMaybe<Scalars['String']>;
  slotBuyer_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotBuyer_starts_with?: InputMaybe<Scalars['String']>;
  slotBuyer_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotSeller?: InputMaybe<Scalars['String']>;
  slotSeller_?: InputMaybe<AccountNftSlot_Filter>;
  slotSeller_contains?: InputMaybe<Scalars['String']>;
  slotSeller_contains_nocase?: InputMaybe<Scalars['String']>;
  slotSeller_ends_with?: InputMaybe<Scalars['String']>;
  slotSeller_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotSeller_gt?: InputMaybe<Scalars['String']>;
  slotSeller_gte?: InputMaybe<Scalars['String']>;
  slotSeller_in?: InputMaybe<Array<Scalars['String']>>;
  slotSeller_lt?: InputMaybe<Scalars['String']>;
  slotSeller_lte?: InputMaybe<Scalars['String']>;
  slotSeller_not?: InputMaybe<Scalars['String']>;
  slotSeller_not_contains?: InputMaybe<Scalars['String']>;
  slotSeller_not_contains_nocase?: InputMaybe<Scalars['String']>;
  slotSeller_not_ends_with?: InputMaybe<Scalars['String']>;
  slotSeller_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slotSeller_not_in?: InputMaybe<Array<Scalars['String']>>;
  slotSeller_not_starts_with?: InputMaybe<Scalars['String']>;
  slotSeller_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slotSeller_starts_with?: InputMaybe<Scalars['String']>;
  slotSeller_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slots?: InputMaybe<Array<Scalars['String']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  slots_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots_not?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  storageIdA?: InputMaybe<Scalars['Int']>;
  storageIdA_gt?: InputMaybe<Scalars['Int']>;
  storageIdA_gte?: InputMaybe<Scalars['Int']>;
  storageIdA_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdA_lt?: InputMaybe<Scalars['Int']>;
  storageIdA_lte?: InputMaybe<Scalars['Int']>;
  storageIdA_not?: InputMaybe<Scalars['Int']>;
  storageIdA_not_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB?: InputMaybe<Scalars['Int']>;
  storageIdB_gt?: InputMaybe<Scalars['Int']>;
  storageIdB_gte?: InputMaybe<Scalars['Int']>;
  storageIdB_in?: InputMaybe<Array<Scalars['Int']>>;
  storageIdB_lt?: InputMaybe<Scalars['Int']>;
  storageIdB_lte?: InputMaybe<Scalars['Int']>;
  storageIdB_not?: InputMaybe<Scalars['Int']>;
  storageIdB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenIDAB?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not?: InputMaybe<Scalars['Int']>;
  tokenIDAB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDAS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDAS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not?: InputMaybe<Scalars['Int']>;
  tokenIDAS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBB_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBB_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not?: InputMaybe<Scalars['Int']>;
  tokenIDBB_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_gte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenIDBS_lt?: InputMaybe<Scalars['Int']>;
  tokenIDBS_lte?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not?: InputMaybe<Scalars['Int']>;
  tokenIDBS_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum TradeNft_OrderBy {
  AccountBuyer = 'accountBuyer',
  AccountIdA = 'accountIdA',
  AccountIdB = 'accountIdB',
  AccountSeller = 'accountSeller',
  Accounts = 'accounts',
  Block = 'block',
  Data = 'data',
  FFillSa = 'fFillSA',
  FFillSb = 'fFillSB',
  FeeBipsA = 'feeBipsA',
  FeeBipsB = 'feeBipsB',
  FeeBipsHiA = 'feeBipsHiA',
  FeeBipsHiB = 'feeBipsHiB',
  FeeBuyer = 'feeBuyer',
  FeeSeller = 'feeSeller',
  FillAmountBorSa = 'fillAmountBorSA',
  FillAmountBorSb = 'fillAmountBorSB',
  FillBa = 'fillBA',
  FillBb = 'fillBB',
  FillSa = 'fillSA',
  FillSb = 'fillSB',
  Id = 'id',
  InternalId = 'internalID',
  LimitMaskA = 'limitMaskA',
  LimitMaskB = 'limitMaskB',
  Nfts = 'nfts',
  OrderDataA = 'orderDataA',
  OrderDataB = 'orderDataB',
  ProtocolFeeBuyer = 'protocolFeeBuyer',
  ProtocolFeeSeller = 'protocolFeeSeller',
  RealizedNftPrice = 'realizedNFTPrice',
  SlotBuyer = 'slotBuyer',
  SlotSeller = 'slotSeller',
  Slots = 'slots',
  StorageIdA = 'storageIdA',
  StorageIdB = 'storageIdB',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenIdab = 'tokenIDAB',
  TokenIdas = 'tokenIDAS',
  TokenIdbb = 'tokenIDBB',
  TokenIdbs = 'tokenIDBS',
  Typename = 'typename',
}

export type Transaction = {
  accounts?: Maybe<Array<Account>>;
  /** Link to the Block entity where this Transaction took place */
  block: Block;
  /** Hex string representation of the encoded L2 data for this Transaction */
  data: Scalars['String'];
  /** All transactions IDs follow the same pattern: <BLOCK ID>-<TX INDEX> */
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type TransactionAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type TransactionTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type TransactionNft = {
  /** Link to the Block entity where this Transaction took place */
  block: Block;
  /** Hex string representation of the encoded L2 data for this Transaction */
  data: Scalars['String'];
  /** All transactions IDs follow the same pattern: <BLOCK ID>-<TX INDEX> */
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  nfts: Array<NonFungibleToken>;
  slots: Array<AccountNftSlot>;
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type TransactionNftNftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type TransactionNftSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type TransactionNft_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  nfts?: InputMaybe<Array<Scalars['String']>>;
  nfts_?: InputMaybe<NonFungibleToken_Filter>;
  nfts_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  nfts_not?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots?: InputMaybe<Array<Scalars['String']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  slots_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots_not?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum TransactionNft_OrderBy {
  Block = 'block',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  Nfts = 'nfts',
  Slots = 'slots',
  Typename = 'typename',
}

export enum TransactionType {
  AccountUpdate = 'AccountUpdate',
  Add = 'Add',
  AmmUpdate = 'AmmUpdate',
  DataNft = 'DataNFT',
  Deposit = 'Deposit',
  MintNft = 'MintNFT',
  OrderbookTrade = 'OrderbookTrade',
  Remove = 'Remove',
  SignatureVerification = 'SignatureVerification',
  Swap = 'Swap',
  SwapNft = 'SwapNFT',
  TradeNft = 'TradeNFT',
  Transfer = 'Transfer',
  TransferNft = 'TransferNFT',
  Withdrawal = 'Withdrawal',
  WithdrawalNft = 'WithdrawalNFT',
}

export type Transaction_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Transaction_OrderBy {
  Accounts = 'accounts',
  Block = 'block',
  Data = 'data',
  Id = 'id',
  InternalId = 'internalID',
  TokenBalances = 'tokenBalances',
  Typename = 'typename',
}

export type Transfer = Transaction & {
  __typename?: 'Transfer';
  /** [RAW L2 DATA] Account ID for the account that sent the tokens */
  accountFromID: Scalars['Int'];
  /** [RAW L2 DATA] Account ID for the account that received the tokens */
  accountToID: Scalars['Int'];
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount transfered */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken: Token;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that sent the tokens */
  from: Scalars['String'];
  /** Account entity that sent the tokens */
  fromAccount: Account;
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] StorageID */
  storageID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that received the tokens */
  to: Scalars['String'];
  /** Account entity that received the tokens */
  toAccount: Account;
  /** [RAW L2 DATA] Token ID of the token transfered. Mainly used for NFT transfers */
  toTokenID: Scalars['Int'];
  /** Token entity with information about the token transfered */
  token: Token;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the token transfered */
  tokenID: Scalars['Int'];
  /** [RAW L2 DATA] Transfer type */
  type: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
};

export type TransferAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type TransferTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type TransferNft = Transaction &
  TransactionNft & {
    __typename?: 'TransferNFT';
    /** [RAW L2 DATA] Account ID for the account that sent the tokens */
    accountFromID: Scalars['Int'];
    /** [RAW L2 DATA] Account ID for the account that received the tokens */
    accountToID: Scalars['Int'];
    accounts?: Maybe<Array<Account>>;
    /** [RAW L2 DATA] Amount transfered */
    amount: Scalars['BigInt'];
    block: Block;
    data: Scalars['String'];
    /** [RAW L2 DATA] Fee amount paid */
    fee: Scalars['BigInt'];
    /** Token entity with information about the token used to pay the operator fees */
    feeToken: Token;
    /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
    feeTokenID: Scalars['Int'];
    /** [RAW L2 DATA] Address string of the account that sent the tokens */
    from: Scalars['String'];
    /** Account entity that sent the tokens */
    fromAccount: Account;
    /** Slot entity from where the NFT is moved */
    fromSlot: AccountNftSlot;
    id: Scalars['ID'];
    /** ID represented as a BigDecimal for sorting purposes */
    internalID: Scalars['BigDecimal'];
    nfts: Array<NonFungibleToken>;
    slots: Array<AccountNftSlot>;
    /** [RAW L2 DATA] StorageID */
    storageID: Scalars['Int'];
    /** [RAW L2 DATA] Address string of the account that received the tokens */
    to: Scalars['String'];
    /** Account entity that received the tokens */
    toAccount: Account;
    /** Slot entity to where the NFT is moved */
    toSlot: AccountNftSlot;
    /** [RAW L2 DATA] Token ID of the token transfered. Mainly used for NFT transfers */
    toTokenID: Scalars['Int'];
    tokenBalances?: Maybe<Array<AccountTokenBalance>>;
    /** [RAW L2 DATA] Token ID of the token transfered */
    tokenID: Scalars['Int'];
    /** [RAW L2 DATA] Transfer type */
    type: Scalars['Int'];
    /** Explicit copy of __typename to make it usable when filtering */
    typename: TransactionType;
  };

export type TransferNftAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type TransferNftNftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type TransferNftSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type TransferNftTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type TransferNft_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountFromID?: InputMaybe<Scalars['Int']>;
  accountFromID_gt?: InputMaybe<Scalars['Int']>;
  accountFromID_gte?: InputMaybe<Scalars['Int']>;
  accountFromID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFromID_lt?: InputMaybe<Scalars['Int']>;
  accountFromID_lte?: InputMaybe<Scalars['Int']>;
  accountFromID_not?: InputMaybe<Scalars['Int']>;
  accountFromID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID?: InputMaybe<Scalars['Int']>;
  accountToID_gt?: InputMaybe<Scalars['Int']>;
  accountToID_gte?: InputMaybe<Scalars['Int']>;
  accountToID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID_lt?: InputMaybe<Scalars['Int']>;
  accountToID_lte?: InputMaybe<Scalars['Int']>;
  accountToID_not?: InputMaybe<Scalars['Int']>;
  accountToID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  fromAccount?: InputMaybe<Scalars['String']>;
  fromAccount_?: InputMaybe<Account_Filter>;
  fromAccount_contains?: InputMaybe<Scalars['String']>;
  fromAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_gt?: InputMaybe<Scalars['String']>;
  fromAccount_gte?: InputMaybe<Scalars['String']>;
  fromAccount_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_lt?: InputMaybe<Scalars['String']>;
  fromAccount_lte?: InputMaybe<Scalars['String']>;
  fromAccount_not?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromSlot?: InputMaybe<Scalars['String']>;
  fromSlot_?: InputMaybe<AccountNftSlot_Filter>;
  fromSlot_contains?: InputMaybe<Scalars['String']>;
  fromSlot_contains_nocase?: InputMaybe<Scalars['String']>;
  fromSlot_ends_with?: InputMaybe<Scalars['String']>;
  fromSlot_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromSlot_gt?: InputMaybe<Scalars['String']>;
  fromSlot_gte?: InputMaybe<Scalars['String']>;
  fromSlot_in?: InputMaybe<Array<Scalars['String']>>;
  fromSlot_lt?: InputMaybe<Scalars['String']>;
  fromSlot_lte?: InputMaybe<Scalars['String']>;
  fromSlot_not?: InputMaybe<Scalars['String']>;
  fromSlot_not_contains?: InputMaybe<Scalars['String']>;
  fromSlot_not_contains_nocase?: InputMaybe<Scalars['String']>;
  fromSlot_not_ends_with?: InputMaybe<Scalars['String']>;
  fromSlot_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromSlot_not_in?: InputMaybe<Array<Scalars['String']>>;
  fromSlot_not_starts_with?: InputMaybe<Scalars['String']>;
  fromSlot_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromSlot_starts_with?: InputMaybe<Scalars['String']>;
  fromSlot_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  nfts?: InputMaybe<Array<Scalars['String']>>;
  nfts_?: InputMaybe<NonFungibleToken_Filter>;
  nfts_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  nfts_not?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots?: InputMaybe<Array<Scalars['String']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  slots_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots_not?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to?: InputMaybe<Scalars['String']>;
  toAccount?: InputMaybe<Scalars['String']>;
  toAccount_?: InputMaybe<Account_Filter>;
  toAccount_contains?: InputMaybe<Scalars['String']>;
  toAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_gt?: InputMaybe<Scalars['String']>;
  toAccount_gte?: InputMaybe<Scalars['String']>;
  toAccount_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_lt?: InputMaybe<Scalars['String']>;
  toAccount_lte?: InputMaybe<Scalars['String']>;
  toAccount_not?: InputMaybe<Scalars['String']>;
  toAccount_not_contains?: InputMaybe<Scalars['String']>;
  toAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toSlot?: InputMaybe<Scalars['String']>;
  toSlot_?: InputMaybe<AccountNftSlot_Filter>;
  toSlot_contains?: InputMaybe<Scalars['String']>;
  toSlot_contains_nocase?: InputMaybe<Scalars['String']>;
  toSlot_ends_with?: InputMaybe<Scalars['String']>;
  toSlot_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toSlot_gt?: InputMaybe<Scalars['String']>;
  toSlot_gte?: InputMaybe<Scalars['String']>;
  toSlot_in?: InputMaybe<Array<Scalars['String']>>;
  toSlot_lt?: InputMaybe<Scalars['String']>;
  toSlot_lte?: InputMaybe<Scalars['String']>;
  toSlot_not?: InputMaybe<Scalars['String']>;
  toSlot_not_contains?: InputMaybe<Scalars['String']>;
  toSlot_not_contains_nocase?: InputMaybe<Scalars['String']>;
  toSlot_not_ends_with?: InputMaybe<Scalars['String']>;
  toSlot_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toSlot_not_in?: InputMaybe<Array<Scalars['String']>>;
  toSlot_not_starts_with?: InputMaybe<Scalars['String']>;
  toSlot_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toSlot_starts_with?: InputMaybe<Scalars['String']>;
  toSlot_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toTokenID?: InputMaybe<Scalars['Int']>;
  toTokenID_gt?: InputMaybe<Scalars['Int']>;
  toTokenID_gte?: InputMaybe<Scalars['Int']>;
  toTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  toTokenID_lt?: InputMaybe<Scalars['Int']>;
  toTokenID_lte?: InputMaybe<Scalars['Int']>;
  toTokenID_not?: InputMaybe<Scalars['Int']>;
  toTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum TransferNft_OrderBy {
  AccountFromId = 'accountFromID',
  AccountToId = 'accountToID',
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  From = 'from',
  FromAccount = 'fromAccount',
  FromSlot = 'fromSlot',
  Id = 'id',
  InternalId = 'internalID',
  Nfts = 'nfts',
  Slots = 'slots',
  StorageId = 'storageID',
  To = 'to',
  ToAccount = 'toAccount',
  ToSlot = 'toSlot',
  ToTokenId = 'toTokenID',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Type = 'type',
  Typename = 'typename',
}

export type Transfer_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountFromID?: InputMaybe<Scalars['Int']>;
  accountFromID_gt?: InputMaybe<Scalars['Int']>;
  accountFromID_gte?: InputMaybe<Scalars['Int']>;
  accountFromID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountFromID_lt?: InputMaybe<Scalars['Int']>;
  accountFromID_lte?: InputMaybe<Scalars['Int']>;
  accountFromID_not?: InputMaybe<Scalars['Int']>;
  accountFromID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID?: InputMaybe<Scalars['Int']>;
  accountToID_gt?: InputMaybe<Scalars['Int']>;
  accountToID_gte?: InputMaybe<Scalars['Int']>;
  accountToID_in?: InputMaybe<Array<Scalars['Int']>>;
  accountToID_lt?: InputMaybe<Scalars['Int']>;
  accountToID_lte?: InputMaybe<Scalars['Int']>;
  accountToID_not?: InputMaybe<Scalars['Int']>;
  accountToID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  fromAccount?: InputMaybe<Scalars['String']>;
  fromAccount_?: InputMaybe<Account_Filter>;
  fromAccount_contains?: InputMaybe<Scalars['String']>;
  fromAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_gt?: InputMaybe<Scalars['String']>;
  fromAccount_gte?: InputMaybe<Scalars['String']>;
  fromAccount_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_lt?: InputMaybe<Scalars['String']>;
  fromAccount_lte?: InputMaybe<Scalars['String']>;
  fromAccount_not?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to?: InputMaybe<Scalars['String']>;
  toAccount?: InputMaybe<Scalars['String']>;
  toAccount_?: InputMaybe<Account_Filter>;
  toAccount_contains?: InputMaybe<Scalars['String']>;
  toAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_gt?: InputMaybe<Scalars['String']>;
  toAccount_gte?: InputMaybe<Scalars['String']>;
  toAccount_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_lt?: InputMaybe<Scalars['String']>;
  toAccount_lte?: InputMaybe<Scalars['String']>;
  toAccount_not?: InputMaybe<Scalars['String']>;
  toAccount_not_contains?: InputMaybe<Scalars['String']>;
  toAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  toAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  toAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toAccount_starts_with?: InputMaybe<Scalars['String']>;
  toAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  toTokenID?: InputMaybe<Scalars['Int']>;
  toTokenID_gt?: InputMaybe<Scalars['Int']>;
  toTokenID_gte?: InputMaybe<Scalars['Int']>;
  toTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  toTokenID_lt?: InputMaybe<Scalars['Int']>;
  toTokenID_lte?: InputMaybe<Scalars['Int']>;
  toTokenID_not?: InputMaybe<Scalars['Int']>;
  toTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
};

export enum Transfer_OrderBy {
  AccountFromId = 'accountFromID',
  AccountToId = 'accountToID',
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  From = 'from',
  FromAccount = 'fromAccount',
  Id = 'id',
  InternalId = 'internalID',
  StorageId = 'storageID',
  To = 'to',
  ToAccount = 'toAccount',
  ToTokenId = 'toTokenID',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Type = 'type',
  Typename = 'typename',
}

export type User = Account & {
  __typename?: 'User';
  address: Scalars['Bytes'];
  balances: Array<AccountTokenBalance>;
  /** L2 transaction internalID where the account was first created and linked to an address. Useful for sorting and filtering purposes */
  createdAt: Scalars['BigDecimal'];
  /** L2 transaction where the account was first created and linked to an address */
  createdAtTransaction: Transaction;
  /** Internal ID used in the L2 transactions */
  id: Scalars['ID'];
  /** Same as ID but expressed as a BigInt for sorting purposes */
  internalID: Scalars['BigInt'];
  /** L2 transaction internalID that last updated the account entity. Useful for sorting and filtering purposes */
  lastUpdatedAt: Scalars['BigDecimal'];
  /** L2 transaction that last updated the account entity */
  lastUpdatedAtTransaction: Transaction;
  /** String representing the public key for the User */
  publicKey?: Maybe<Scalars['String']>;
  /** List of all the AccountNFTSlot entities that this account has. Those slots can be empty but will only exist if they held an NFT at some point. */
  slots: Array<AccountNftSlot>;
  /** L2 transactions that involved this account */
  transactions: Array<Transaction>;
};

export type UserBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type UserSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type UserTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Transaction_Filter>;
};

export type User_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  address?: InputMaybe<Scalars['Bytes']>;
  address_contains?: InputMaybe<Scalars['Bytes']>;
  address_in?: InputMaybe<Array<Scalars['Bytes']>>;
  address_not?: InputMaybe<Scalars['Bytes']>;
  address_not_contains?: InputMaybe<Scalars['Bytes']>;
  address_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  balances_?: InputMaybe<AccountTokenBalance_Filter>;
  createdAt?: InputMaybe<Scalars['BigDecimal']>;
  createdAtTransaction?: InputMaybe<Scalars['String']>;
  createdAtTransaction_?: InputMaybe<Transaction_Filter>;
  createdAtTransaction_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_gte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_lt?: InputMaybe<Scalars['String']>;
  createdAtTransaction_lte?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  createdAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  createdAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  createdAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  createdAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not?: InputMaybe<Scalars['BigDecimal']>;
  createdAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigInt']>;
  internalID_gt?: InputMaybe<Scalars['BigInt']>;
  internalID_gte?: InputMaybe<Scalars['BigInt']>;
  internalID_in?: InputMaybe<Array<Scalars['BigInt']>>;
  internalID_lt?: InputMaybe<Scalars['BigInt']>;
  internalID_lte?: InputMaybe<Scalars['BigInt']>;
  internalID_not?: InputMaybe<Scalars['BigInt']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  lastUpdatedAt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAtTransaction?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_?: InputMaybe<Transaction_Filter>;
  lastUpdatedAtTransaction_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_gte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_lt?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_lte?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_contains_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_in?: InputMaybe<Array<Scalars['String']>>;
  lastUpdatedAtTransaction_not_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with?: InputMaybe<Scalars['String']>;
  lastUpdatedAtTransaction_starts_with_nocase?: InputMaybe<Scalars['String']>;
  lastUpdatedAt_gt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_gte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  lastUpdatedAt_lt?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_lte?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not?: InputMaybe<Scalars['BigDecimal']>;
  lastUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  publicKey?: InputMaybe<Scalars['String']>;
  publicKey_contains?: InputMaybe<Scalars['String']>;
  publicKey_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_gt?: InputMaybe<Scalars['String']>;
  publicKey_gte?: InputMaybe<Scalars['String']>;
  publicKey_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_lt?: InputMaybe<Scalars['String']>;
  publicKey_lte?: InputMaybe<Scalars['String']>;
  publicKey_not?: InputMaybe<Scalars['String']>;
  publicKey_not_contains?: InputMaybe<Scalars['String']>;
  publicKey_not_contains_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with?: InputMaybe<Scalars['String']>;
  publicKey_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_not_in?: InputMaybe<Array<Scalars['String']>>;
  publicKey_not_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  publicKey_starts_with?: InputMaybe<Scalars['String']>;
  publicKey_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  transactions_?: InputMaybe<Transaction_Filter>;
};

export enum User_OrderBy {
  Address = 'address',
  Balances = 'balances',
  CreatedAt = 'createdAt',
  CreatedAtTransaction = 'createdAtTransaction',
  Id = 'id',
  InternalId = 'internalID',
  LastUpdatedAt = 'lastUpdatedAt',
  LastUpdatedAtTransaction = 'lastUpdatedAtTransaction',
  PublicKey = 'publicKey',
  Slots = 'slots',
  Transactions = 'transactions',
}

export type Withdrawal = Transaction & {
  __typename?: 'Withdrawal';
  accounts?: Maybe<Array<Account>>;
  /** [RAW L2 DATA] Amount withdrawn */
  amount: Scalars['BigInt'];
  block: Block;
  data: Scalars['String'];
  /** [RAW L2 DATA] Fee amount paid */
  fee: Scalars['BigInt'];
  /** Token entity with information about the token used to pay the operator fees */
  feeToken?: Maybe<Token>;
  /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
  feeTokenID: Scalars['Int'];
  /** [RAW L2 DATA] Address string of the account that withdrew */
  from: Scalars['String'];
  /** Account entity that withdrew the tokens */
  fromAccount: Account;
  /** [RAW L2 DATA] Account ID for the account that withdrew */
  fromAccountID: Scalars['Int'];
  id: Scalars['ID'];
  /** ID represented as a BigDecimal for sorting purposes */
  internalID: Scalars['BigDecimal'];
  /** [RAW L2 DATA] On-chain data hash */
  onchainDataHash: Scalars['String'];
  /** [RAW L2 DATA] StorageID */
  storageID: Scalars['Int'];
  /** Token entity with information about the withdrawn token */
  token?: Maybe<Token>;
  tokenBalances?: Maybe<Array<AccountTokenBalance>>;
  /** [RAW L2 DATA] Token ID of the withdrawn token */
  tokenID: Scalars['Int'];
  /** [RAW L2 DATA] Withdrawal type */
  type: Scalars['Int'];
  /** Explicit copy of __typename to make it usable when filtering */
  typename: TransactionType;
  /** Whether the withdrawal transaction is valid. Only type 3 withdrawals are invalid. */
  valid: Scalars['Boolean'];
};

export type WithdrawalAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type WithdrawalTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type WithdrawalNft = Transaction &
  TransactionNft & {
    __typename?: 'WithdrawalNFT';
    accounts?: Maybe<Array<Account>>;
    /** [RAW L2 DATA] Amount withdrawn */
    amount: Scalars['BigInt'];
    block: Block;
    data: Scalars['String'];
    /** [RAW L2 DATA] Fee amount paid */
    fee: Scalars['BigInt'];
    /** Token entity with information about the token used to pay the operator fees */
    feeToken?: Maybe<Token>;
    /** [RAW L2 DATA] Token ID of token used to pay the operator fees */
    feeTokenID: Scalars['Int'];
    /** [RAW L2 DATA] Address string of the account that withdrew */
    from: Scalars['String'];
    /** Account entity that withdrew the tokens */
    fromAccount: Account;
    /** [RAW L2 DATA] Account ID for the account that withdrew */
    fromAccountID: Scalars['Int'];
    id: Scalars['ID'];
    /** ID represented as a BigDecimal for sorting purposes */
    internalID: Scalars['BigDecimal'];
    nfts: Array<NonFungibleToken>;
    /** [RAW L2 DATA] On-chain data hash */
    onchainDataHash: Scalars['String'];
    /** Slot entity with information about the withdrawn NFT */
    slot: AccountNftSlot;
    slots: Array<AccountNftSlot>;
    /** [RAW L2 DATA] StorageID */
    storageID: Scalars['Int'];
    tokenBalances?: Maybe<Array<AccountTokenBalance>>;
    /** [RAW L2 DATA] Token ID of the withdrawn token */
    tokenID: Scalars['Int'];
    /** [RAW L2 DATA] Withdrawal type */
    type: Scalars['Int'];
    /** Explicit copy of __typename to make it usable when filtering */
    typename: TransactionType;
    /** Whether the withdrawal transaction is valid. Only type 3 withdrawals are invalid. */
    valid: Scalars['Boolean'];
  };

export type WithdrawalNftAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
};

export type WithdrawalNftNftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NonFungibleToken_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NonFungibleToken_Filter>;
};

export type WithdrawalNftSlotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountNftSlot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountNftSlot_Filter>;
};

export type WithdrawalNftTokenBalancesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenBalance_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenBalance_Filter>;
};

export type WithdrawalNft_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  fromAccount?: InputMaybe<Scalars['String']>;
  fromAccountID?: InputMaybe<Scalars['Int']>;
  fromAccountID_gt?: InputMaybe<Scalars['Int']>;
  fromAccountID_gte?: InputMaybe<Scalars['Int']>;
  fromAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  fromAccountID_lt?: InputMaybe<Scalars['Int']>;
  fromAccountID_lte?: InputMaybe<Scalars['Int']>;
  fromAccountID_not?: InputMaybe<Scalars['Int']>;
  fromAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fromAccount_?: InputMaybe<Account_Filter>;
  fromAccount_contains?: InputMaybe<Scalars['String']>;
  fromAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_gt?: InputMaybe<Scalars['String']>;
  fromAccount_gte?: InputMaybe<Scalars['String']>;
  fromAccount_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_lt?: InputMaybe<Scalars['String']>;
  fromAccount_lte?: InputMaybe<Scalars['String']>;
  fromAccount_not?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  nfts?: InputMaybe<Array<Scalars['String']>>;
  nfts_?: InputMaybe<NonFungibleToken_Filter>;
  nfts_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  nfts_not?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  nfts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  onchainDataHash?: InputMaybe<Scalars['String']>;
  onchainDataHash_contains?: InputMaybe<Scalars['String']>;
  onchainDataHash_contains_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_ends_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_ends_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_gt?: InputMaybe<Scalars['String']>;
  onchainDataHash_gte?: InputMaybe<Scalars['String']>;
  onchainDataHash_in?: InputMaybe<Array<Scalars['String']>>;
  onchainDataHash_lt?: InputMaybe<Scalars['String']>;
  onchainDataHash_lte?: InputMaybe<Scalars['String']>;
  onchainDataHash_not?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_contains?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_contains_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_ends_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_in?: InputMaybe<Array<Scalars['String']>>;
  onchainDataHash_not_starts_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_starts_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slot?: InputMaybe<Scalars['String']>;
  slot_?: InputMaybe<AccountNftSlot_Filter>;
  slot_contains?: InputMaybe<Scalars['String']>;
  slot_contains_nocase?: InputMaybe<Scalars['String']>;
  slot_ends_with?: InputMaybe<Scalars['String']>;
  slot_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slot_gt?: InputMaybe<Scalars['String']>;
  slot_gte?: InputMaybe<Scalars['String']>;
  slot_in?: InputMaybe<Array<Scalars['String']>>;
  slot_lt?: InputMaybe<Scalars['String']>;
  slot_lte?: InputMaybe<Scalars['String']>;
  slot_not?: InputMaybe<Scalars['String']>;
  slot_not_contains?: InputMaybe<Scalars['String']>;
  slot_not_contains_nocase?: InputMaybe<Scalars['String']>;
  slot_not_ends_with?: InputMaybe<Scalars['String']>;
  slot_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  slot_not_in?: InputMaybe<Array<Scalars['String']>>;
  slot_not_starts_with?: InputMaybe<Scalars['String']>;
  slot_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slot_starts_with?: InputMaybe<Scalars['String']>;
  slot_starts_with_nocase?: InputMaybe<Scalars['String']>;
  slots?: InputMaybe<Array<Scalars['String']>>;
  slots_?: InputMaybe<AccountNftSlot_Filter>;
  slots_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  slots_not?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains?: InputMaybe<Array<Scalars['String']>>;
  slots_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
  valid?: InputMaybe<Scalars['Boolean']>;
  valid_in?: InputMaybe<Array<Scalars['Boolean']>>;
  valid_not?: InputMaybe<Scalars['Boolean']>;
  valid_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
};

export enum WithdrawalNft_OrderBy {
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  From = 'from',
  FromAccount = 'fromAccount',
  FromAccountId = 'fromAccountID',
  Id = 'id',
  InternalId = 'internalID',
  Nfts = 'nfts',
  OnchainDataHash = 'onchainDataHash',
  Slot = 'slot',
  Slots = 'slots',
  StorageId = 'storageID',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Type = 'type',
  Typename = 'typename',
  Valid = 'valid',
}

export type Withdrawal_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accounts?: InputMaybe<Array<Scalars['String']>>;
  accounts_?: InputMaybe<Account_Filter>;
  accounts_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  accounts_not?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains?: InputMaybe<Array<Scalars['String']>>;
  accounts_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  block?: InputMaybe<Scalars['String']>;
  block_?: InputMaybe<Block_Filter>;
  block_contains?: InputMaybe<Scalars['String']>;
  block_contains_nocase?: InputMaybe<Scalars['String']>;
  block_ends_with?: InputMaybe<Scalars['String']>;
  block_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_gt?: InputMaybe<Scalars['String']>;
  block_gte?: InputMaybe<Scalars['String']>;
  block_in?: InputMaybe<Array<Scalars['String']>>;
  block_lt?: InputMaybe<Scalars['String']>;
  block_lte?: InputMaybe<Scalars['String']>;
  block_not?: InputMaybe<Scalars['String']>;
  block_not_contains?: InputMaybe<Scalars['String']>;
  block_not_contains_nocase?: InputMaybe<Scalars['String']>;
  block_not_ends_with?: InputMaybe<Scalars['String']>;
  block_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  block_not_in?: InputMaybe<Array<Scalars['String']>>;
  block_not_starts_with?: InputMaybe<Scalars['String']>;
  block_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  block_starts_with?: InputMaybe<Scalars['String']>;
  block_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data?: InputMaybe<Scalars['String']>;
  data_contains?: InputMaybe<Scalars['String']>;
  data_contains_nocase?: InputMaybe<Scalars['String']>;
  data_ends_with?: InputMaybe<Scalars['String']>;
  data_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_gt?: InputMaybe<Scalars['String']>;
  data_gte?: InputMaybe<Scalars['String']>;
  data_in?: InputMaybe<Array<Scalars['String']>>;
  data_lt?: InputMaybe<Scalars['String']>;
  data_lte?: InputMaybe<Scalars['String']>;
  data_not?: InputMaybe<Scalars['String']>;
  data_not_contains?: InputMaybe<Scalars['String']>;
  data_not_contains_nocase?: InputMaybe<Scalars['String']>;
  data_not_ends_with?: InputMaybe<Scalars['String']>;
  data_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  data_not_in?: InputMaybe<Array<Scalars['String']>>;
  data_not_starts_with?: InputMaybe<Scalars['String']>;
  data_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  data_starts_with?: InputMaybe<Scalars['String']>;
  data_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee?: InputMaybe<Scalars['BigInt']>;
  feeToken?: InputMaybe<Scalars['String']>;
  feeTokenID?: InputMaybe<Scalars['Int']>;
  feeTokenID_gt?: InputMaybe<Scalars['Int']>;
  feeTokenID_gte?: InputMaybe<Scalars['Int']>;
  feeTokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  feeTokenID_lt?: InputMaybe<Scalars['Int']>;
  feeTokenID_lte?: InputMaybe<Scalars['Int']>;
  feeTokenID_not?: InputMaybe<Scalars['Int']>;
  feeTokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  feeToken_?: InputMaybe<Token_Filter>;
  feeToken_contains?: InputMaybe<Scalars['String']>;
  feeToken_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_gt?: InputMaybe<Scalars['String']>;
  feeToken_gte?: InputMaybe<Scalars['String']>;
  feeToken_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_lt?: InputMaybe<Scalars['String']>;
  feeToken_lte?: InputMaybe<Scalars['String']>;
  feeToken_not?: InputMaybe<Scalars['String']>;
  feeToken_not_contains?: InputMaybe<Scalars['String']>;
  feeToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with?: InputMaybe<Scalars['String']>;
  feeToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  feeToken_not_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  feeToken_starts_with?: InputMaybe<Scalars['String']>;
  feeToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fee_gt?: InputMaybe<Scalars['BigInt']>;
  fee_gte?: InputMaybe<Scalars['BigInt']>;
  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;
  fee_lt?: InputMaybe<Scalars['BigInt']>;
  fee_lte?: InputMaybe<Scalars['BigInt']>;
  fee_not?: InputMaybe<Scalars['BigInt']>;
  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  fromAccount?: InputMaybe<Scalars['String']>;
  fromAccountID?: InputMaybe<Scalars['Int']>;
  fromAccountID_gt?: InputMaybe<Scalars['Int']>;
  fromAccountID_gte?: InputMaybe<Scalars['Int']>;
  fromAccountID_in?: InputMaybe<Array<Scalars['Int']>>;
  fromAccountID_lt?: InputMaybe<Scalars['Int']>;
  fromAccountID_lte?: InputMaybe<Scalars['Int']>;
  fromAccountID_not?: InputMaybe<Scalars['Int']>;
  fromAccountID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  fromAccount_?: InputMaybe<Account_Filter>;
  fromAccount_contains?: InputMaybe<Scalars['String']>;
  fromAccount_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_gt?: InputMaybe<Scalars['String']>;
  fromAccount_gte?: InputMaybe<Scalars['String']>;
  fromAccount_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_lt?: InputMaybe<Scalars['String']>;
  fromAccount_lte?: InputMaybe<Scalars['String']>;
  fromAccount_not?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains?: InputMaybe<Scalars['String']>;
  fromAccount_not_contains_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_not_in?: InputMaybe<Array<Scalars['String']>>;
  fromAccount_not_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with?: InputMaybe<Scalars['String']>;
  fromAccount_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  internalID?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_gte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  internalID_lt?: InputMaybe<Scalars['BigDecimal']>;
  internalID_lte?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not?: InputMaybe<Scalars['BigDecimal']>;
  internalID_not_in?: InputMaybe<Array<Scalars['BigDecimal']>>;
  onchainDataHash?: InputMaybe<Scalars['String']>;
  onchainDataHash_contains?: InputMaybe<Scalars['String']>;
  onchainDataHash_contains_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_ends_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_ends_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_gt?: InputMaybe<Scalars['String']>;
  onchainDataHash_gte?: InputMaybe<Scalars['String']>;
  onchainDataHash_in?: InputMaybe<Array<Scalars['String']>>;
  onchainDataHash_lt?: InputMaybe<Scalars['String']>;
  onchainDataHash_lte?: InputMaybe<Scalars['String']>;
  onchainDataHash_not?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_contains?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_contains_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_ends_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_in?: InputMaybe<Array<Scalars['String']>>;
  onchainDataHash_not_starts_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  onchainDataHash_starts_with?: InputMaybe<Scalars['String']>;
  onchainDataHash_starts_with_nocase?: InputMaybe<Scalars['String']>;
  storageID?: InputMaybe<Scalars['Int']>;
  storageID_gt?: InputMaybe<Scalars['Int']>;
  storageID_gte?: InputMaybe<Scalars['Int']>;
  storageID_in?: InputMaybe<Array<Scalars['Int']>>;
  storageID_lt?: InputMaybe<Scalars['Int']>;
  storageID_lte?: InputMaybe<Scalars['Int']>;
  storageID_not?: InputMaybe<Scalars['Int']>;
  storageID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token?: InputMaybe<Scalars['String']>;
  tokenBalances?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_?: InputMaybe<AccountTokenBalance_Filter>;
  tokenBalances_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains?: InputMaybe<Array<Scalars['String']>>;
  tokenBalances_not_contains_nocase?: InputMaybe<Array<Scalars['String']>>;
  tokenID?: InputMaybe<Scalars['Int']>;
  tokenID_gt?: InputMaybe<Scalars['Int']>;
  tokenID_gte?: InputMaybe<Scalars['Int']>;
  tokenID_in?: InputMaybe<Array<Scalars['Int']>>;
  tokenID_lt?: InputMaybe<Scalars['Int']>;
  tokenID_lte?: InputMaybe<Scalars['Int']>;
  tokenID_not?: InputMaybe<Scalars['Int']>;
  tokenID_not_in?: InputMaybe<Array<Scalars['Int']>>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  typename?: InputMaybe<TransactionType>;
  typename_in?: InputMaybe<Array<TransactionType>>;
  typename_not?: InputMaybe<TransactionType>;
  typename_not_in?: InputMaybe<Array<TransactionType>>;
  valid?: InputMaybe<Scalars['Boolean']>;
  valid_in?: InputMaybe<Array<Scalars['Boolean']>>;
  valid_not?: InputMaybe<Scalars['Boolean']>;
  valid_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
};

export enum Withdrawal_OrderBy {
  Accounts = 'accounts',
  Amount = 'amount',
  Block = 'block',
  Data = 'data',
  Fee = 'fee',
  FeeToken = 'feeToken',
  FeeTokenId = 'feeTokenID',
  From = 'from',
  FromAccount = 'fromAccount',
  FromAccountId = 'fromAccountID',
  Id = 'id',
  InternalId = 'internalID',
  OnchainDataHash = 'onchainDataHash',
  StorageId = 'storageID',
  Token = 'token',
  TokenBalances = 'tokenBalances',
  TokenId = 'tokenID',
  Type = 'type',
  Typename = 'typename',
  Valid = 'valid',
}

export type _Block_ = {
  __typename?: '_Block_';
  /** The hash of the block */
  hash?: Maybe<Scalars['Bytes']>;
  /** The block number */
  number: Scalars['Int'];
  /** Integer representation of the timestamp stored in blocks for the chain */
  timestamp?: Maybe<Scalars['Int']>;
};

/** The type for the top-level _meta field */
export type _Meta_ = {
  __typename?: '_Meta_';
  /**
   * Information about a specific subgraph block. The hash of the block
   * will be null if the _meta field has a block constraint that asks for
   * a block number. It will be filled if the _meta field has no block constraint
   * and therefore asks for the latest  block
   *
   */
  block: _Block_;
  /** The deployment ID */
  deployment: Scalars['String'];
  /** If `true`, the subgraph encountered indexing errors at some past block */
  hasIndexingErrors: Scalars['Boolean'];
};

export enum _SubgraphErrorPolicy_ {
  /** Data will be returned even if the subgraph has indexing errors */
  Allow = 'allow',
  /** If the subgraph has indexing errors, data will be omitted. The default. */
  Deny = 'deny',
}

type AccountFragment_Pool_Fragment = { __typename?: 'Pool'; id: string; address: any };

type AccountFragment_ProtocolAccount_Fragment = { __typename?: 'ProtocolAccount'; id: string; address: any };

type AccountFragment_User_Fragment = { __typename?: 'User'; id: string; address: any };

export type AccountFragmentFragment =
  | AccountFragment_Pool_Fragment
  | AccountFragment_ProtocolAccount_Fragment
  | AccountFragment_User_Fragment;

export type TokenFragmentFragment = {
  __typename?: 'Token';
  id: string;
  name: string;
  symbol: string;
  decimals: number;
  address: any;
};

export type BlockFragmentFragment = {
  __typename?: 'Block';
  id: string;
  timestamp: any;
  txHash: string;
  gasLimit: any;
  gasPrice: any;
  height: any;
  blockHash: string;
  blockSize: number;
  operatorAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
};

export type PoolFragmentFragment = {
  __typename?: 'Pool';
  id: string;
  address: any;
  balances: Array<{
    __typename?: 'AccountTokenBalance';
    id: string;
    balance: any;
    token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  }>;
};

export type NftFragmentFragment = {
  __typename?: 'NonFungibleToken';
  id: string;
  nftID: string;
  nftType: number;
  token: string;
  minter:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
};

export type AddFragmentFragment = {
  __typename: 'Add';
  id: string;
  amount: any;
  fee: any;
  account:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  pool: {
    __typename?: 'Pool';
    id: string;
    address: any;
    balances: Array<{
      __typename?: 'AccountTokenBalance';
      id: string;
      balance: any;
      token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    }>;
  };
  token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type RemoveFragmentFragment = {
  __typename: 'Remove';
  id: string;
  amount: any;
  fee: any;
  account:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  pool: {
    __typename?: 'Pool';
    id: string;
    address: any;
    balances: Array<{
      __typename?: 'AccountTokenBalance';
      id: string;
      balance: any;
      token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    }>;
  };
  token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type SwapFragmentFragment = {
  __typename: 'Swap';
  id: string;
  tokenAPrice: any;
  tokenBPrice: any;
  fillSA: any;
  fillSB: any;
  fillBA: any;
  protocolFeeA: any;
  protocolFeeB: any;
  feeA: any;
  feeB: any;
  account:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  pool: {
    __typename?: 'Pool';
    id: string;
    address: any;
    balances: Array<{
      __typename?: 'AccountTokenBalance';
      id: string;
      balance: any;
      token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    }>;
  };
  tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  pair: {
    __typename?: 'Pair';
    id: string;
    token0: { __typename?: 'Token'; symbol: string };
    token1: { __typename?: 'Token'; symbol: string };
  };
};

export type OrderbookTradeFragmentFragment = {
  __typename: 'OrderbookTrade';
  id: string;
  tokenAPrice: any;
  tokenBPrice: any;
  fillSA: any;
  fillSB: any;
  fillBA: any;
  fillBB: any;
  fillAmountBorSA: boolean;
  fillAmountBorSB: boolean;
  feeA: any;
  feeB: any;
  accountA:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  accountB:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  pair: {
    __typename?: 'Pair';
    id: string;
    token0: { __typename?: 'Token'; symbol: string };
    token1: { __typename?: 'Token'; symbol: string };
  };
};

export type DepositFragmentFragment = {
  __typename: 'Deposit';
  id: string;
  amount: any;
  toAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type WithdrawalFragmentFragment = {
  __typename: 'Withdrawal';
  amount: any;
  fee: any;
  fromAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  withdrawalToken?: {
    __typename?: 'Token';
    id: string;
    name: string;
    symbol: string;
    decimals: number;
    address: any;
  } | null;
  withdrawalFeeToken?: {
    __typename?: 'Token';
    id: string;
    name: string;
    symbol: string;
    decimals: number;
    address: any;
  } | null;
};

export type TransferFragmentFragment = {
  __typename: 'Transfer';
  amount: any;
  fee: any;
  fromAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  toAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type AccountUpdateFragmentFragment = {
  __typename: 'AccountUpdate';
  fee: any;
  nonce: number;
  user: { __typename?: 'User'; id: string; address: any; publicKey?: string | null };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type AmmUpdateFragmentFragment = {
  __typename: 'AmmUpdate';
  tokenID: number;
  feeBips: number;
  tokenWeight: any;
  nonce: number;
  balance: any;
  pool: {
    __typename?: 'Pool';
    id: string;
    address: any;
    balances: Array<{
      __typename?: 'AccountTokenBalance';
      id: string;
      balance: any;
      token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    }>;
  };
  tokenBalances?: Array<{
    __typename?: 'AccountTokenBalance';
    id: string;
    balance: any;
    token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  }> | null;
};

export type SignatureVerificationFragmentFragment = {
  __typename: 'SignatureVerification';
  verificationData: string;
  account:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
};

export type TradeNftFragmentFragment = {
  __typename: 'TradeNFT';
  accountIdA: number;
  accountIdB: number;
  storageIdA: number;
  storageIdB: number;
  tokenIDAS: number;
  tokenIDAB: number;
  tokenIDBS: number;
  tokenIDBB: number;
  realizedNFTPrice: any;
  feeBuyer: any;
  feeSeller: any;
  protocolFeeBuyer: any;
  accountSeller:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  accountBuyer:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  nfts: Array<{
    __typename?: 'NonFungibleToken';
    id: string;
    nftID: string;
    nftType: number;
    token: string;
    minter:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  }>;
};

export type SwapNftFragmentFragment = {
  __typename: 'SwapNFT';
  accountA:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  accountB:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  nfts: Array<{
    __typename?: 'NonFungibleToken';
    id: string;
    nftID: string;
    nftType: number;
    token: string;
    minter:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  }>;
};

export type WithdrawalNftFragmentFragment = {
  __typename: 'WithdrawalNFT';
  fee: any;
  fromAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  withdrawalNFTFeeToken?: {
    __typename?: 'Token';
    id: string;
    name: string;
    symbol: string;
    decimals: number;
    address: any;
  } | null;
  nfts: Array<{
    __typename?: 'NonFungibleToken';
    id: string;
    nftID: string;
    nftType: number;
    token: string;
    minter:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  }>;
};

export type TransferNftFragmentFragment = {
  __typename: 'TransferNFT';
  fee: any;
  fromAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  toAccount:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  nfts: Array<{
    __typename?: 'NonFungibleToken';
    id: string;
    nftID: string;
    nftType: number;
    token: string;
    minter:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  }>;
};

export type MintNftFragmentFragment = {
  __typename: 'MintNFT';
  fee: any;
  amount: any;
  minter:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  receiver:
    | { __typename?: 'Pool'; id: string; address: any }
    | { __typename?: 'ProtocolAccount'; id: string; address: any }
    | { __typename?: 'User'; id: string; address: any };
  receiverSlot: { __typename?: 'AccountNFTSlot'; id: string };
  nft: { __typename?: 'NonFungibleToken'; id: string };
  feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
};

export type DataNftFragmentFragment = { __typename: 'DataNFT'; id: string };

export type AccountsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Account_Filter>;
}>;

export type AccountsQuery = {
  __typename?: 'Query';
  accounts: Array<
    | {
        __typename: 'Pool';
        feeBipsAMM?: number | null;
        id: string;
        address: any;
        createdAtTransaction:
          | { __typename?: 'AccountUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Add'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'AmmUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'DataNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Deposit'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'MintNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'OrderbookTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Remove'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SignatureVerification'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Swap'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SwapNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'TradeNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Transfer'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'TransferNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Withdrawal'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'WithdrawalNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } };
      }
    | {
        __typename: 'ProtocolAccount';
        id: string;
        address: any;
        createdAtTransaction:
          | { __typename?: 'AccountUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Add'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'AmmUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'DataNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Deposit'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'MintNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'OrderbookTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Remove'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SignatureVerification'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Swap'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SwapNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'TradeNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Transfer'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'TransferNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Withdrawal'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'WithdrawalNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } };
      }
    | {
        __typename: 'User';
        id: string;
        address: any;
        createdAtTransaction:
          | { __typename?: 'AccountUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Add'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'AmmUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'DataNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Deposit'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'MintNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'OrderbookTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Remove'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SignatureVerification'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Swap'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'SwapNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'TradeNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Transfer'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'TransferNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'Withdrawal'; id: string; block: { __typename?: 'Block'; timestamp: any } }
          | { __typename?: 'WithdrawalNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } };
      }
  >;
};

export type AccountTokenBalancesQueryVariables = Exact<{
  where?: InputMaybe<AccountTokenBalance_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type AccountTokenBalancesQuery = {
  __typename?: 'Query';
  accountTokenBalances: Array<{
    __typename: 'AccountTokenBalance';
    id: string;
    balance: any;
    token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
  }>;
};

export type AccountNftSlotsQueryVariables = Exact<{
  where?: InputMaybe<AccountNftSlot_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type AccountNftSlotsQuery = {
  __typename?: 'Query';
  accountNFTSlots: Array<{
    __typename?: 'AccountNFTSlot';
    id: string;
    balance: any;
    nft?: {
      __typename?: 'NonFungibleToken';
      id: string;
      nftID: string;
      nftType: number;
      token: string;
      minter:
        | { __typename?: 'Pool'; id: string; address: any }
        | { __typename?: 'ProtocolAccount'; id: string; address: any }
        | { __typename?: 'User'; id: string; address: any };
    } | null;
    createdAtTransaction:
      | { __typename?: 'AccountUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'Add'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'AmmUpdate'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'DataNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'Deposit'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'MintNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'OrderbookTrade'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'Remove'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'SignatureVerification'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'Swap'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'SwapNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'TradeNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'Transfer'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'TransferNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'Withdrawal'; id: string; block: { __typename?: 'Block'; timestamp: any } }
      | { __typename?: 'WithdrawalNFT'; id: string; block: { __typename?: 'Block'; timestamp: any } };
  }>;
};

export type BlocksQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Block_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type BlocksQuery = {
  __typename?: 'Query';
  blocks: Array<{
    __typename?: 'Block';
    transactionCount: any;
    id: string;
    timestamp: any;
    txHash: string;
    gasLimit: any;
    gasPrice: any;
    height: any;
    blockHash: string;
    blockSize: number;
    operatorAccount:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  }>;
};

export type BlockQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type BlockQuery = {
  __typename?: 'Query';
  proxy?: { __typename?: 'Proxy'; blockCount: any } | null;
  block?: {
    __typename?: 'Block';
    data: string;
    id: string;
    timestamp: any;
    txHash: string;
    gasLimit: any;
    gasPrice: any;
    height: any;
    blockHash: string;
    blockSize: number;
    operatorAccount:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  } | null;
};

export type NetworkStatsQueryVariables = Exact<{ [key: string]: never }>;

export type NetworkStatsQuery = {
  __typename?: 'Query';
  proxy?: { __typename?: 'Proxy'; blockCount: any; userCount: any; transactionCount: any } | null;
  blocks: Array<{ __typename?: 'Block'; id: string; transactionCount: any; timestamp: any }>;
};

export type NonFungibleTokenQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type NonFungibleTokenQuery = {
  __typename?: 'Query';
  nonFungibleToken?: {
    __typename: 'NonFungibleToken';
    id: string;
    nftID: string;
    nftType: number;
    token: string;
    minter:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  } | null;
};

export type TransactionNfTsQueryVariables = Exact<{
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<TransactionNft_Filter>;
}>;

export type TransactionNfTsQuery = {
  __typename?: 'Query';
  transactionNFTs: Array<
    | {
        __typename: 'DataNFT';
        id: string;
        internalID: any;
        data: string;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
      }
    | {
        __typename: 'MintNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        amount: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
        minter:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        receiver:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        receiverSlot: { __typename?: 'AccountNFTSlot'; id: string };
        nft: { __typename?: 'NonFungibleToken'; id: string };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'SwapNFT';
        id: string;
        internalID: any;
        data: string;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
        accountA:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'TradeNFT';
        id: string;
        internalID: any;
        data: string;
        accountIdA: number;
        accountIdB: number;
        storageIdA: number;
        storageIdB: number;
        tokenIDAS: number;
        tokenIDAB: number;
        tokenIDBS: number;
        tokenIDBB: number;
        realizedNFTPrice: any;
        feeBuyer: any;
        feeSeller: any;
        protocolFeeBuyer: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
        accountSeller:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountBuyer:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'TransferNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        toAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'WithdrawalNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        withdrawalNFTFeeToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
  >;
};

export type NonFungibleTokensQueryVariables = Exact<{
  where?: InputMaybe<NonFungibleToken_Filter>;
  first?: InputMaybe<Scalars['Int']>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type NonFungibleTokensQuery = {
  __typename?: 'Query';
  nonFungibleTokens: Array<{
    __typename: 'NonFungibleToken';
    id: string;
    nftID: string;
    nftType: number;
    token: string;
    minter:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
  }>;
};

export type PairsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Pair_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type PairsQuery = {
  __typename?: 'Query';
  pairs: Array<{
    __typename?: 'Pair';
    id: string;
    internalID: any;
    tradedVolumeToken0Swap: any;
    token0: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    token1: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    dailyEntities: Array<{
      __typename?: 'PairDailyData';
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Swap: any;
      id: string;
    }>;
    weeklyEntities: Array<{
      __typename?: 'PairWeeklyData';
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Swap: any;
      id: string;
    }>;
  }>;
};

export type PairQueryVariables = Exact<{
  id: Scalars['ID'];
  swapSkip?: InputMaybe<Scalars['Int']>;
  swapFirst?: InputMaybe<Scalars['Int']>;
  orderbookSkip?: InputMaybe<Scalars['Int']>;
  orderbookFirst?: InputMaybe<Scalars['Int']>;
}>;

export type PairQuery = {
  __typename?: 'Query';
  pair?: {
    __typename: 'Pair';
    id: string;
    internalID: any;
    token0Price: any;
    token1Price: any;
    tradedVolumeToken0Swap: any;
    tradedVolumeToken1Swap: any;
    tradedVolumeToken0Orderbook: any;
    tradedVolumeToken1Orderbook: any;
    token0: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    token1: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    trades: Array<{
      __typename: 'OrderbookTrade';
      id: string;
      tokenAPrice: any;
      tokenBPrice: any;
      fillSA: any;
      fillSB: any;
      fillBA: any;
      fillBB: any;
      fillAmountBorSA: boolean;
      fillAmountBorSB: boolean;
      feeA: any;
      feeB: any;
      block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
      accountA:
        | { __typename?: 'Pool'; id: string; address: any }
        | { __typename?: 'ProtocolAccount'; id: string; address: any }
        | { __typename?: 'User'; id: string; address: any };
      accountB:
        | { __typename?: 'Pool'; id: string; address: any }
        | { __typename?: 'ProtocolAccount'; id: string; address: any }
        | { __typename?: 'User'; id: string; address: any };
      tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      pair: {
        __typename?: 'Pair';
        id: string;
        token0: { __typename?: 'Token'; symbol: string };
        token1: { __typename?: 'Token'; symbol: string };
      };
    }>;
    dailyEntities: Array<{
      __typename?: 'PairDailyData';
      dayEnd: any;
      tradedVolumeToken0: any;
      tradedVolumeToken1: any;
      tradedVolumeToken0Swap: any;
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Orderbook: any;
      tradedVolumeToken1Orderbook: any;
    }>;
    weeklyEntities: Array<{
      __typename?: 'PairWeeklyData';
      weekEnd: any;
      tradedVolumeToken0: any;
      tradedVolumeToken1: any;
      tradedVolumeToken0Swap: any;
      tradedVolumeToken1Swap: any;
      tradedVolumeToken0Orderbook: any;
      tradedVolumeToken1Orderbook: any;
    }>;
  } | null;
};

export type PairSwapsQueryVariables = Exact<{
  where?: InputMaybe<Swap_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type PairSwapsQuery = {
  __typename?: 'Query';
  swaps: Array<{
    __typename: 'Swap';
    internalID: any;
    id: string;
    tokenAPrice: any;
    tokenBPrice: any;
    fillSA: any;
    fillSB: any;
    fillBA: any;
    protocolFeeA: any;
    protocolFeeB: any;
    feeA: any;
    feeB: any;
    block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
    account:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
    pool: {
      __typename?: 'Pool';
      id: string;
      address: any;
      balances: Array<{
        __typename?: 'AccountTokenBalance';
        id: string;
        balance: any;
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }>;
    };
    tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    pair: {
      __typename?: 'Pair';
      id: string;
      token0: { __typename?: 'Token'; symbol: string };
      token1: { __typename?: 'Token'; symbol: string };
    };
  }>;
};

export type PairTradesQueryVariables = Exact<{
  where?: InputMaybe<OrderbookTrade_Filter>;
  orderDirection?: InputMaybe<OrderDirection>;
}>;

export type PairTradesQuery = {
  __typename?: 'Query';
  orderbookTrades: Array<{
    __typename: 'OrderbookTrade';
    internalID: any;
    id: string;
    tokenAPrice: any;
    tokenBPrice: any;
    fillSA: any;
    fillSB: any;
    fillBA: any;
    fillBB: any;
    fillAmountBorSA: boolean;
    fillAmountBorSB: boolean;
    feeA: any;
    feeB: any;
    block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any };
    accountA:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
    accountB:
      | { __typename?: 'Pool'; id: string; address: any }
      | { __typename?: 'ProtocolAccount'; id: string; address: any }
      | { __typename?: 'User'; id: string; address: any };
    tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
    pair: {
      __typename?: 'Pair';
      id: string;
      token0: { __typename?: 'Token'; symbol: string };
      token1: { __typename?: 'Token'; symbol: string };
    };
  }>;
};

export type TransactionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Transaction_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  where?: InputMaybe<Transaction_Filter>;
}>;

export type TransactionsQuery = {
  __typename?: 'Query';
  transactions: Array<
    | {
        __typename: 'AccountUpdate';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        nonce: number;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        user: { __typename?: 'User'; id: string; address: any; publicKey?: string | null };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'Add';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'AmmUpdate';
        id: string;
        internalID: any;
        data: string;
        tokenID: number;
        feeBips: number;
        tokenWeight: any;
        nonce: number;
        balance: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        tokenBalances?: Array<{
          __typename?: 'AccountTokenBalance';
          id: string;
          balance: any;
          token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        }> | null;
      }
    | {
        __typename: 'DataNFT';
        id: string;
        internalID: any;
        data: string;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
      }
    | {
        __typename: 'Deposit';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        toAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'MintNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        amount: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        minter:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        receiver:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        receiverSlot: { __typename?: 'AccountNFTSlot'; id: string };
        nft: { __typename?: 'NonFungibleToken'; id: string };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'OrderbookTrade';
        id: string;
        internalID: any;
        data: string;
        tokenAPrice: any;
        tokenBPrice: any;
        fillSA: any;
        fillSB: any;
        fillBA: any;
        fillBB: any;
        fillAmountBorSA: boolean;
        fillAmountBorSB: boolean;
        feeA: any;
        feeB: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        accountA:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        pair: {
          __typename?: 'Pair';
          id: string;
          token0: { __typename?: 'Token'; symbol: string };
          token1: { __typename?: 'Token'; symbol: string };
        };
      }
    | {
        __typename: 'Remove';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'SignatureVerification';
        id: string;
        internalID: any;
        data: string;
        verificationData: string;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
      }
    | {
        __typename: 'Swap';
        id: string;
        internalID: any;
        data: string;
        tokenAPrice: any;
        tokenBPrice: any;
        fillSA: any;
        fillSB: any;
        fillBA: any;
        protocolFeeA: any;
        protocolFeeB: any;
        feeA: any;
        feeB: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        pair: {
          __typename?: 'Pair';
          id: string;
          token0: { __typename?: 'Token'; symbol: string };
          token1: { __typename?: 'Token'; symbol: string };
        };
      }
    | {
        __typename: 'SwapNFT';
        id: string;
        internalID: any;
        data: string;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        accountA:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'TradeNFT';
        id: string;
        internalID: any;
        data: string;
        accountIdA: number;
        accountIdB: number;
        storageIdA: number;
        storageIdB: number;
        tokenIDAS: number;
        tokenIDAB: number;
        tokenIDBS: number;
        tokenIDBB: number;
        realizedNFTPrice: any;
        feeBuyer: any;
        feeSeller: any;
        protocolFeeBuyer: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        accountSeller:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountBuyer:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'Transfer';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        toAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'TransferNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        toAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'Withdrawal';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        withdrawalToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
        withdrawalFeeToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
      }
    | {
        __typename: 'WithdrawalNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        block: { __typename?: 'Block'; id: string; blockHash: string; timestamp: any; txHash: string };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        withdrawalNFTFeeToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
  >;
};

export type TransactionQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type TransactionQuery = {
  __typename?: 'Query';
  transaction?:
    | {
        __typename: 'AccountUpdate';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        nonce: number;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        user: { __typename?: 'User'; id: string; address: any; publicKey?: string | null };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'Add';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'AmmUpdate';
        id: string;
        internalID: any;
        data: string;
        tokenID: number;
        feeBips: number;
        tokenWeight: any;
        nonce: number;
        balance: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        tokenBalances?: Array<{
          __typename?: 'AccountTokenBalance';
          id: string;
          balance: any;
          token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        }> | null;
      }
    | {
        __typename: 'DataNFT';
        id: string;
        internalID: any;
        data: string;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
      }
    | {
        __typename: 'Deposit';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        toAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'MintNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        amount: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        minter:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        receiver:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        receiverSlot: { __typename?: 'AccountNFTSlot'; id: string };
        nft: { __typename?: 'NonFungibleToken'; id: string };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'OrderbookTrade';
        id: string;
        internalID: any;
        data: string;
        tokenAPrice: any;
        tokenBPrice: any;
        fillSA: any;
        fillSB: any;
        fillBA: any;
        fillBB: any;
        fillAmountBorSA: boolean;
        fillAmountBorSB: boolean;
        feeA: any;
        feeB: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        accountA:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        pair: {
          __typename?: 'Pair';
          id: string;
          token0: { __typename?: 'Token'; symbol: string };
          token1: { __typename?: 'Token'; symbol: string };
        };
      }
    | {
        __typename: 'Remove';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'SignatureVerification';
        id: string;
        internalID: any;
        data: string;
        verificationData: string;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
      }
    | {
        __typename: 'Swap';
        id: string;
        internalID: any;
        data: string;
        tokenAPrice: any;
        tokenBPrice: any;
        fillSA: any;
        fillSB: any;
        fillBA: any;
        protocolFeeA: any;
        protocolFeeB: any;
        feeA: any;
        feeB: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        account:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        pool: {
          __typename?: 'Pool';
          id: string;
          address: any;
          balances: Array<{
            __typename?: 'AccountTokenBalance';
            id: string;
            balance: any;
            token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
          }>;
        };
        tokenA: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        tokenB: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        pair: {
          __typename?: 'Pair';
          id: string;
          token0: { __typename?: 'Token'; symbol: string };
          token1: { __typename?: 'Token'; symbol: string };
        };
      }
    | {
        __typename: 'SwapNFT';
        id: string;
        internalID: any;
        data: string;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        accountA:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountB:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'TradeNFT';
        id: string;
        internalID: any;
        data: string;
        accountIdA: number;
        accountIdB: number;
        storageIdA: number;
        storageIdB: number;
        tokenIDAS: number;
        tokenIDAB: number;
        tokenIDBS: number;
        tokenIDBB: number;
        realizedNFTPrice: any;
        feeBuyer: any;
        feeSeller: any;
        protocolFeeBuyer: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        accountSeller:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        accountBuyer:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'Transfer';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        toAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        token: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
      }
    | {
        __typename: 'TransferNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        toAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        feeToken: { __typename?: 'Token'; id: string; name: string; symbol: string; decimals: number; address: any };
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | {
        __typename: 'Withdrawal';
        id: string;
        internalID: any;
        data: string;
        amount: any;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        withdrawalToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
        withdrawalFeeToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
      }
    | {
        __typename: 'WithdrawalNFT';
        id: string;
        internalID: any;
        data: string;
        fee: any;
        block: {
          __typename?: 'Block';
          id: string;
          blockHash: string;
          timestamp: any;
          transactionCount: any;
          txHash: string;
        };
        fromAccount:
          | { __typename?: 'Pool'; id: string; address: any }
          | { __typename?: 'ProtocolAccount'; id: string; address: any }
          | { __typename?: 'User'; id: string; address: any };
        withdrawalNFTFeeToken?: {
          __typename?: 'Token';
          id: string;
          name: string;
          symbol: string;
          decimals: number;
          address: any;
        } | null;
        nfts: Array<{
          __typename?: 'NonFungibleToken';
          id: string;
          nftID: string;
          nftType: number;
          token: string;
          minter:
            | { __typename?: 'Pool'; id: string; address: any }
            | { __typename?: 'ProtocolAccount'; id: string; address: any }
            | { __typename?: 'User'; id: string; address: any };
        }>;
      }
    | null;
};

export type PendingTransactionsQueryVariables = Exact<{
  transferWhere?: InputMaybe<Transfer_Filter>;
  withdrawalWhere?: InputMaybe<Withdrawal_Filter>;
  addWhere?: InputMaybe<Add_Filter>;
  removeWhere?: InputMaybe<Remove_Filter>;
  orderBookTradeWhere?: InputMaybe<OrderbookTrade_Filter>;
  mintNFTWhere?: InputMaybe<MintNft_Filter>;
  withdrawNFTWhere?: InputMaybe<WithdrawalNft_Filter>;
  transferNFTWhere?: InputMaybe<TransferNft_Filter>;
  swapWhere?: InputMaybe<Swap_Filter>;
  tradeNFTWhereA?: InputMaybe<TradeNft_Filter>;
  tradeNFTWhereB?: InputMaybe<TradeNft_Filter>;
  accountUpdateWhere?: InputMaybe<AccountUpdate_Filter>;
}>;

export type PendingTransactionsQuery = {
  __typename?: 'Query';
  transfers: Array<{ __typename?: 'Transfer'; id: string }>;
  withdrawals: Array<{ __typename?: 'Withdrawal'; id: string }>;
  adds: Array<{ __typename?: 'Add'; id: string }>;
  removes: Array<{ __typename?: 'Remove'; id: string }>;
  orderbookTrades: Array<{ __typename?: 'OrderbookTrade'; id: string }>;
  mintNFTs: Array<{ __typename?: 'MintNFT'; id: string }>;
  withdrawalNFTs: Array<{ __typename?: 'WithdrawalNFT'; id: string }>;
  transferNFTs: Array<{ __typename?: 'TransferNFT'; id: string }>;
  swaps: Array<{ __typename?: 'Swap'; id: string }>;
  tradeNFTs: Array<{ __typename?: 'TradeNFT'; id: string }>;
  tradeNFTsB: Array<{ __typename?: 'TradeNFT'; id: string }>;
  accountUpdates: Array<{ __typename?: 'AccountUpdate'; id: string }>;
};

export const AccountFragmentFragmentDoc = gql`
  fragment AccountFragment on Account {
    id
    address
  }
`;
export const BlockFragmentFragmentDoc = gql`
  fragment BlockFragment on Block {
    id
    timestamp
    txHash
    gasLimit
    gasPrice
    height
    blockHash
    blockSize
    gasPrice
    operatorAccount {
      ...AccountFragment
    }
  }
  ${AccountFragmentFragmentDoc}
`;
export const TokenFragmentFragmentDoc = gql`
  fragment TokenFragment on Token {
    id
    name
    symbol
    decimals
    address
  }
`;
export const PoolFragmentFragmentDoc = gql`
  fragment PoolFragment on Pool {
    id
    address
    balances {
      id
      balance
      token {
        ...TokenFragment
      }
    }
  }
  ${TokenFragmentFragmentDoc}
`;
export const AddFragmentFragmentDoc = gql`
  fragment AddFragment on Add {
    id
    account {
      ...AccountFragment
    }
    pool {
      ...PoolFragment
    }
    token {
      ...TokenFragment
    }
    feeToken {
      ...TokenFragment
    }
    amount
    fee
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${PoolFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const RemoveFragmentFragmentDoc = gql`
  fragment RemoveFragment on Remove {
    id
    account {
      ...AccountFragment
    }
    pool {
      ...PoolFragment
    }
    token {
      ...TokenFragment
    }
    feeToken {
      ...TokenFragment
    }
    amount
    fee
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${PoolFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const SwapFragmentFragmentDoc = gql`
  fragment SwapFragment on Swap {
    id
    account {
      ...AccountFragment
    }
    pool {
      ...PoolFragment
    }
    tokenA {
      ...TokenFragment
    }
    tokenB {
      ...TokenFragment
    }
    pair {
      id
      token0 {
        symbol
      }
      token1 {
        symbol
      }
    }
    tokenAPrice
    tokenBPrice
    fillSA
    fillSB
    fillBA
    protocolFeeA
    protocolFeeB
    feeA
    feeB
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${PoolFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const OrderbookTradeFragmentFragmentDoc = gql`
  fragment OrderbookTradeFragment on OrderbookTrade {
    id
    accountA {
      ...AccountFragment
    }
    accountB {
      ...AccountFragment
    }
    tokenA {
      ...TokenFragment
    }
    tokenB {
      ...TokenFragment
    }
    pair {
      id
      token0 {
        symbol
      }
      token1 {
        symbol
      }
    }
    tokenAPrice
    tokenBPrice
    fillSA
    fillSB
    fillBA
    fillBB
    fillAmountBorSA
    fillAmountBorSB
    feeA
    feeB
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const DepositFragmentFragmentDoc = gql`
  fragment DepositFragment on Deposit {
    id
    toAccount {
      ...AccountFragment
    }
    token {
      ...TokenFragment
    }
    amount
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const WithdrawalFragmentFragmentDoc = gql`
  fragment WithdrawalFragment on Withdrawal {
    fromAccount {
      ...AccountFragment
    }
    withdrawalToken: token {
      ...TokenFragment
    }
    withdrawalFeeToken: feeToken {
      ...TokenFragment
    }
    amount
    fee
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const TransferFragmentFragmentDoc = gql`
  fragment TransferFragment on Transfer {
    fromAccount {
      ...AccountFragment
    }
    toAccount {
      ...AccountFragment
    }
    token {
      ...TokenFragment
    }
    feeToken {
      ...TokenFragment
    }
    amount
    fee
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const AccountUpdateFragmentFragmentDoc = gql`
  fragment AccountUpdateFragment on AccountUpdate {
    user {
      id
      address
      publicKey
    }
    feeToken {
      ...TokenFragment
    }
    fee
    nonce
    __typename
  }
  ${TokenFragmentFragmentDoc}
`;
export const AmmUpdateFragmentFragmentDoc = gql`
  fragment AmmUpdateFragment on AmmUpdate {
    pool {
      ...PoolFragment
    }
    tokenID
    feeBips
    tokenWeight
    nonce
    balance
    tokenBalances {
      id
      balance
      token {
        ...TokenFragment
      }
    }
    __typename
  }
  ${PoolFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const SignatureVerificationFragmentFragmentDoc = gql`
  fragment SignatureVerificationFragment on SignatureVerification {
    account {
      ...AccountFragment
    }
    verificationData
    __typename
  }
  ${AccountFragmentFragmentDoc}
`;
export const NftFragmentFragmentDoc = gql`
  fragment NFTFragment on NonFungibleToken {
    id
    minter {
      ...AccountFragment
    }
    nftID
    nftType
    token
  }
  ${AccountFragmentFragmentDoc}
`;
export const TradeNftFragmentFragmentDoc = gql`
  fragment TradeNFTFragment on TradeNFT {
    accountSeller {
      ...AccountFragment
    }
    accountIdA
    accountIdB
    storageIdA
    storageIdB
    tokenIDAS
    tokenIDAB
    tokenIDBS
    tokenIDBB
    accountBuyer {
      ...AccountFragment
    }
    token {
      ...TokenFragment
    }
    nfts {
      ...NFTFragment
    }
    realizedNFTPrice
    feeBuyer
    feeSeller
    protocolFeeBuyer
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
  ${NftFragmentFragmentDoc}
`;
export const SwapNftFragmentFragmentDoc = gql`
  fragment SwapNFTFragment on SwapNFT {
    accountA {
      ...AccountFragment
    }
    accountB {
      ...AccountFragment
    }
    nfts {
      ...NFTFragment
    }
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${NftFragmentFragmentDoc}
`;
export const WithdrawalNftFragmentFragmentDoc = gql`
  fragment WithdrawalNFTFragment on WithdrawalNFT {
    fromAccount {
      ...AccountFragment
    }
    fee
    withdrawalNFTFeeToken: feeToken {
      ...TokenFragment
    }
    nfts {
      ...NFTFragment
    }
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
  ${NftFragmentFragmentDoc}
`;
export const TransferNftFragmentFragmentDoc = gql`
  fragment TransferNFTFragment on TransferNFT {
    fromAccount {
      ...AccountFragment
    }
    toAccount {
      ...AccountFragment
    }
    feeToken {
      ...TokenFragment
    }
    nfts {
      ...NFTFragment
    }
    fee
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
  ${NftFragmentFragmentDoc}
`;
export const MintNftFragmentFragmentDoc = gql`
  fragment MintNFTFragment on MintNFT {
    minter {
      ...AccountFragment
    }
    receiver {
      ...AccountFragment
    }
    receiverSlot {
      id
    }
    nft {
      id
    }
    fee
    feeToken {
      ...TokenFragment
    }
    amount
    __typename
  }
  ${AccountFragmentFragmentDoc}
  ${TokenFragmentFragmentDoc}
`;
export const DataNftFragmentFragmentDoc = gql`
  fragment DataNFTFragment on DataNFT {
    id
    __typename
  }
`;
export const AccountsDocument = gql`
  query accounts($first: Int, $where: Account_filter) {
    accounts(first: $first, where: $where) {
      id
      address
      createdAtTransaction {
        id
        block {
          timestamp
        }
      }
      ... on Pool {
        feeBipsAMM
      }
      __typename
    }
  }
`;

/**
 * __useAccountsQuery__
 *
 * To run a query within a React component, call `useAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useAccountsQuery(baseOptions?: Apollo.QueryHookOptions<AccountsQuery, AccountsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<AccountsQuery, AccountsQueryVariables>(AccountsDocument, options);
}
export function useAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountsQuery, AccountsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<AccountsQuery, AccountsQueryVariables>(AccountsDocument, options);
}
export type AccountsQueryHookResult = ReturnType<typeof useAccountsQuery>;
export type AccountsLazyQueryHookResult = ReturnType<typeof useAccountsLazyQuery>;
export type AccountsQueryResult = Apollo.QueryResult<AccountsQuery, AccountsQueryVariables>;
export function refetchAccountsQuery(variables?: AccountsQueryVariables) {
  return { query: AccountsDocument, variables: variables };
}
export const AccountTokenBalancesDocument = gql`
  query accountTokenBalances($where: AccountTokenBalance_filter, $orderDirection: OrderDirection) {
    accountTokenBalances(orderDirection: $orderDirection, orderBy: id, first: 10, where: $where) {
      id
      balance
      token {
        ...TokenFragment
      }
      __typename
    }
  }
  ${TokenFragmentFragmentDoc}
`;

/**
 * __useAccountTokenBalancesQuery__
 *
 * To run a query within a React component, call `useAccountTokenBalancesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountTokenBalancesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountTokenBalancesQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function useAccountTokenBalancesQuery(
  baseOptions?: Apollo.QueryHookOptions<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>(
    AccountTokenBalancesDocument,
    options
  );
}
export function useAccountTokenBalancesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<AccountTokenBalancesQuery, AccountTokenBalancesQueryVariables>(
    AccountTokenBalancesDocument,
    options
  );
}
export type AccountTokenBalancesQueryHookResult = ReturnType<typeof useAccountTokenBalancesQuery>;
export type AccountTokenBalancesLazyQueryHookResult = ReturnType<typeof useAccountTokenBalancesLazyQuery>;
export type AccountTokenBalancesQueryResult = Apollo.QueryResult<
  AccountTokenBalancesQuery,
  AccountTokenBalancesQueryVariables
>;
export function refetchAccountTokenBalancesQuery(variables?: AccountTokenBalancesQueryVariables) {
  return { query: AccountTokenBalancesDocument, variables: variables };
}
export const AccountNftSlotsDocument = gql`
  query accountNFTSlots($where: AccountNFTSlot_filter, $orderDirection: OrderDirection) {
    accountNFTSlots(orderDirection: $orderDirection, orderBy: id, first: 8, where: $where) {
      id
      nft {
        ...NFTFragment
      }
      balance
      createdAtTransaction {
        id
        block {
          timestamp
        }
      }
    }
  }
  ${NftFragmentFragmentDoc}
`;

/**
 * __useAccountNftSlotsQuery__
 *
 * To run a query within a React component, call `useAccountNftSlotsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountNftSlotsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountNftSlotsQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function useAccountNftSlotsQuery(
  baseOptions?: Apollo.QueryHookOptions<AccountNftSlotsQuery, AccountNftSlotsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<AccountNftSlotsQuery, AccountNftSlotsQueryVariables>(AccountNftSlotsDocument, options);
}
export function useAccountNftSlotsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<AccountNftSlotsQuery, AccountNftSlotsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<AccountNftSlotsQuery, AccountNftSlotsQueryVariables>(AccountNftSlotsDocument, options);
}
export type AccountNftSlotsQueryHookResult = ReturnType<typeof useAccountNftSlotsQuery>;
export type AccountNftSlotsLazyQueryHookResult = ReturnType<typeof useAccountNftSlotsLazyQuery>;
export type AccountNftSlotsQueryResult = Apollo.QueryResult<AccountNftSlotsQuery, AccountNftSlotsQueryVariables>;
export function refetchAccountNftSlotsQuery(variables?: AccountNftSlotsQueryVariables) {
  return { query: AccountNftSlotsDocument, variables: variables };
}
export const BlocksDocument = gql`
  query blocks($first: Int, $where: Block_filter, $orderDirection: OrderDirection) {
    blocks(first: $first, where: $where, orderBy: internalID, orderDirection: $orderDirection) {
      ...BlockFragment
      transactionCount
    }
  }
  ${BlockFragmentFragmentDoc}
`;

/**
 * __useBlocksQuery__
 *
 * To run a query within a React component, call `useBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlocksQuery({
 *   variables: {
 *      first: // value for 'first'
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function useBlocksQuery(baseOptions?: Apollo.QueryHookOptions<BlocksQuery, BlocksQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<BlocksQuery, BlocksQueryVariables>(BlocksDocument, options);
}
export function useBlocksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlocksQuery, BlocksQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<BlocksQuery, BlocksQueryVariables>(BlocksDocument, options);
}
export type BlocksQueryHookResult = ReturnType<typeof useBlocksQuery>;
export type BlocksLazyQueryHookResult = ReturnType<typeof useBlocksLazyQuery>;
export type BlocksQueryResult = Apollo.QueryResult<BlocksQuery, BlocksQueryVariables>;
export function refetchBlocksQuery(variables?: BlocksQueryVariables) {
  return { query: BlocksDocument, variables: variables };
}
export const BlockDocument = gql`
  query block($id: ID!) {
    proxy(id: 0) {
      blockCount
    }
    block(id: $id) {
      ...BlockFragment
      data
    }
  }
  ${BlockFragmentFragmentDoc}
`;

/**
 * __useBlockQuery__
 *
 * To run a query within a React component, call `useBlockQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlockQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlockQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBlockQuery(baseOptions: Apollo.QueryHookOptions<BlockQuery, BlockQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<BlockQuery, BlockQueryVariables>(BlockDocument, options);
}
export function useBlockLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlockQuery, BlockQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<BlockQuery, BlockQueryVariables>(BlockDocument, options);
}
export type BlockQueryHookResult = ReturnType<typeof useBlockQuery>;
export type BlockLazyQueryHookResult = ReturnType<typeof useBlockLazyQuery>;
export type BlockQueryResult = Apollo.QueryResult<BlockQuery, BlockQueryVariables>;
export function refetchBlockQuery(variables: BlockQueryVariables) {
  return { query: BlockDocument, variables: variables };
}
export const NetworkStatsDocument = gql`
  query networkStats {
    proxy(id: 0) {
      blockCount
      userCount
      transactionCount
    }
    blocks(first: 10, orderBy: internalID, orderDirection: desc) {
      id
      transactionCount
      timestamp
    }
  }
`;

/**
 * __useNetworkStatsQuery__
 *
 * To run a query within a React component, call `useNetworkStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNetworkStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNetworkStatsQuery({
 *   variables: {
 *   },
 * });
 */
export function useNetworkStatsQuery(
  baseOptions?: Apollo.QueryHookOptions<NetworkStatsQuery, NetworkStatsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<NetworkStatsQuery, NetworkStatsQueryVariables>(NetworkStatsDocument, options);
}
export function useNetworkStatsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NetworkStatsQuery, NetworkStatsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<NetworkStatsQuery, NetworkStatsQueryVariables>(NetworkStatsDocument, options);
}
export type NetworkStatsQueryHookResult = ReturnType<typeof useNetworkStatsQuery>;
export type NetworkStatsLazyQueryHookResult = ReturnType<typeof useNetworkStatsLazyQuery>;
export type NetworkStatsQueryResult = Apollo.QueryResult<NetworkStatsQuery, NetworkStatsQueryVariables>;
export function refetchNetworkStatsQuery(variables?: NetworkStatsQueryVariables) {
  return { query: NetworkStatsDocument, variables: variables };
}
export const NonFungibleTokenDocument = gql`
  query nonFungibleToken($id: ID!) {
    nonFungibleToken(id: $id) {
      ...NFTFragment
      __typename
    }
  }
  ${NftFragmentFragmentDoc}
`;

/**
 * __useNonFungibleTokenQuery__
 *
 * To run a query within a React component, call `useNonFungibleTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useNonFungibleTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNonFungibleTokenQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useNonFungibleTokenQuery(
  baseOptions: Apollo.QueryHookOptions<NonFungibleTokenQuery, NonFungibleTokenQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<NonFungibleTokenQuery, NonFungibleTokenQueryVariables>(NonFungibleTokenDocument, options);
}
export function useNonFungibleTokenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NonFungibleTokenQuery, NonFungibleTokenQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<NonFungibleTokenQuery, NonFungibleTokenQueryVariables>(NonFungibleTokenDocument, options);
}
export type NonFungibleTokenQueryHookResult = ReturnType<typeof useNonFungibleTokenQuery>;
export type NonFungibleTokenLazyQueryHookResult = ReturnType<typeof useNonFungibleTokenLazyQuery>;
export type NonFungibleTokenQueryResult = Apollo.QueryResult<NonFungibleTokenQuery, NonFungibleTokenQueryVariables>;
export function refetchNonFungibleTokenQuery(variables: NonFungibleTokenQueryVariables) {
  return { query: NonFungibleTokenDocument, variables: variables };
}
export const TransactionNfTsDocument = gql`
  query transactionNFTs($orderDirection: OrderDirection, $where: TransactionNFT_filter) {
    transactionNFTs(first: 10, orderBy: internalID, orderDirection: $orderDirection, where: $where) {
      id
      internalID
      block {
        id
        blockHash
        timestamp
      }
      data
      ...TradeNFTFragment
      ...SwapNFTFragment
      ...WithdrawalNFTFragment
      ...TransferNFTFragment
      ...MintNFTFragment
      ...DataNFTFragment
    }
  }
  ${TradeNftFragmentFragmentDoc}
  ${SwapNftFragmentFragmentDoc}
  ${WithdrawalNftFragmentFragmentDoc}
  ${TransferNftFragmentFragmentDoc}
  ${MintNftFragmentFragmentDoc}
  ${DataNftFragmentFragmentDoc}
`;

/**
 * __useTransactionNfTsQuery__
 *
 * To run a query within a React component, call `useTransactionNfTsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionNfTsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionNfTsQuery({
 *   variables: {
 *      orderDirection: // value for 'orderDirection'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useTransactionNfTsQuery(
  baseOptions?: Apollo.QueryHookOptions<TransactionNfTsQuery, TransactionNfTsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<TransactionNfTsQuery, TransactionNfTsQueryVariables>(TransactionNfTsDocument, options);
}
export function useTransactionNfTsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<TransactionNfTsQuery, TransactionNfTsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<TransactionNfTsQuery, TransactionNfTsQueryVariables>(TransactionNfTsDocument, options);
}
export type TransactionNfTsQueryHookResult = ReturnType<typeof useTransactionNfTsQuery>;
export type TransactionNfTsLazyQueryHookResult = ReturnType<typeof useTransactionNfTsLazyQuery>;
export type TransactionNfTsQueryResult = Apollo.QueryResult<TransactionNfTsQuery, TransactionNfTsQueryVariables>;
export function refetchTransactionNfTsQuery(variables?: TransactionNfTsQueryVariables) {
  return { query: TransactionNfTsDocument, variables: variables };
}
export const NonFungibleTokensDocument = gql`
  query nonFungibleTokens($where: NonFungibleToken_filter, $first: Int, $orderDirection: OrderDirection) {
    nonFungibleTokens(where: $where, first: $first, orderDirection: $orderDirection, orderBy: nftID) {
      ...NFTFragment
      __typename
    }
  }
  ${NftFragmentFragmentDoc}
`;

/**
 * __useNonFungibleTokensQuery__
 *
 * To run a query within a React component, call `useNonFungibleTokensQuery` and pass it any options that fit your needs.
 * When your component renders, `useNonFungibleTokensQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNonFungibleTokensQuery({
 *   variables: {
 *      where: // value for 'where'
 *      first: // value for 'first'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function useNonFungibleTokensQuery(
  baseOptions?: Apollo.QueryHookOptions<NonFungibleTokensQuery, NonFungibleTokensQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<NonFungibleTokensQuery, NonFungibleTokensQueryVariables>(NonFungibleTokensDocument, options);
}
export function useNonFungibleTokensLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NonFungibleTokensQuery, NonFungibleTokensQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<NonFungibleTokensQuery, NonFungibleTokensQueryVariables>(
    NonFungibleTokensDocument,
    options
  );
}
export type NonFungibleTokensQueryHookResult = ReturnType<typeof useNonFungibleTokensQuery>;
export type NonFungibleTokensLazyQueryHookResult = ReturnType<typeof useNonFungibleTokensLazyQuery>;
export type NonFungibleTokensQueryResult = Apollo.QueryResult<NonFungibleTokensQuery, NonFungibleTokensQueryVariables>;
export function refetchNonFungibleTokensQuery(variables?: NonFungibleTokensQueryVariables) {
  return { query: NonFungibleTokensDocument, variables: variables };
}
export const PairsDocument = gql`
  query pairs($first: Int, $where: Pair_filter, $orderDirection: OrderDirection) {
    pairs(first: $first, where: $where, orderBy: tradedVolumeToken0Swap, orderDirection: $orderDirection) {
      id
      internalID
      token0 {
        ...TokenFragment
      }
      token1 {
        ...TokenFragment
      }
      tradedVolumeToken0Swap
      dailyEntities(skip: 1, first: 1, orderBy: dayEnd, orderDirection: desc) {
        tradedVolumeToken1Swap
        tradedVolumeToken0Swap
        id
      }
      weeklyEntities(skip: 0, first: 1, orderBy: weekEnd, orderDirection: desc) {
        tradedVolumeToken1Swap
        tradedVolumeToken0Swap
        id
      }
    }
  }
  ${TokenFragmentFragmentDoc}
`;

/**
 * __usePairsQuery__
 *
 * To run a query within a React component, call `usePairsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePairsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePairsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function usePairsQuery(baseOptions?: Apollo.QueryHookOptions<PairsQuery, PairsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PairsQuery, PairsQueryVariables>(PairsDocument, options);
}
export function usePairsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PairsQuery, PairsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PairsQuery, PairsQueryVariables>(PairsDocument, options);
}
export type PairsQueryHookResult = ReturnType<typeof usePairsQuery>;
export type PairsLazyQueryHookResult = ReturnType<typeof usePairsLazyQuery>;
export type PairsQueryResult = Apollo.QueryResult<PairsQuery, PairsQueryVariables>;
export function refetchPairsQuery(variables?: PairsQueryVariables) {
  return { query: PairsDocument, variables: variables };
}
export const PairDocument = gql`
  query pair($id: ID!, $swapSkip: Int, $swapFirst: Int, $orderbookSkip: Int, $orderbookFirst: Int) {
    pair(id: $id) {
      id
      internalID
      token0 {
        ...TokenFragment
      }
      token1 {
        ...TokenFragment
      }
      token0Price
      token1Price
      tradedVolumeToken0Swap
      tradedVolumeToken1Swap
      tradedVolumeToken0Orderbook
      tradedVolumeToken1Orderbook
      trades(skip: $orderbookSkip, first: $orderbookFirst, orderDirection: desc, orderBy: internalID) {
        block {
          id
          blockHash
          timestamp
        }
        ...OrderbookTradeFragment
      }
      dailyEntities(skip: 1, first: 90, orderDirection: desc, orderBy: dayEnd) {
        dayEnd
        tradedVolumeToken0
        tradedVolumeToken1
        tradedVolumeToken0Swap
        tradedVolumeToken1Swap
        tradedVolumeToken0Orderbook
        tradedVolumeToken1Orderbook
      }
      weeklyEntities(skip: 1, first: 90, orderDirection: desc, orderBy: weekEnd) {
        weekEnd
        tradedVolumeToken0
        tradedVolumeToken1
        tradedVolumeToken0Swap
        tradedVolumeToken1Swap
        tradedVolumeToken0Orderbook
        tradedVolumeToken1Orderbook
      }
      __typename
    }
  }
  ${TokenFragmentFragmentDoc}
  ${OrderbookTradeFragmentFragmentDoc}
`;

/**
 * __usePairQuery__
 *
 * To run a query within a React component, call `usePairQuery` and pass it any options that fit your needs.
 * When your component renders, `usePairQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePairQuery({
 *   variables: {
 *      id: // value for 'id'
 *      swapSkip: // value for 'swapSkip'
 *      swapFirst: // value for 'swapFirst'
 *      orderbookSkip: // value for 'orderbookSkip'
 *      orderbookFirst: // value for 'orderbookFirst'
 *   },
 * });
 */
export function usePairQuery(baseOptions: Apollo.QueryHookOptions<PairQuery, PairQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PairQuery, PairQueryVariables>(PairDocument, options);
}
export function usePairLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PairQuery, PairQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PairQuery, PairQueryVariables>(PairDocument, options);
}
export type PairQueryHookResult = ReturnType<typeof usePairQuery>;
export type PairLazyQueryHookResult = ReturnType<typeof usePairLazyQuery>;
export type PairQueryResult = Apollo.QueryResult<PairQuery, PairQueryVariables>;
export function refetchPairQuery(variables: PairQueryVariables) {
  return { query: PairDocument, variables: variables };
}
export const PairSwapsDocument = gql`
  query pairSwaps($where: Swap_filter, $orderDirection: OrderDirection) {
    swaps(first: 10, orderDirection: $orderDirection, orderBy: internalID, where: $where) {
      block {
        id
        blockHash
        timestamp
      }
      internalID
      ...SwapFragment
    }
  }
  ${SwapFragmentFragmentDoc}
`;

/**
 * __usePairSwapsQuery__
 *
 * To run a query within a React component, call `usePairSwapsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePairSwapsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePairSwapsQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function usePairSwapsQuery(baseOptions?: Apollo.QueryHookOptions<PairSwapsQuery, PairSwapsQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PairSwapsQuery, PairSwapsQueryVariables>(PairSwapsDocument, options);
}
export function usePairSwapsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<PairSwapsQuery, PairSwapsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PairSwapsQuery, PairSwapsQueryVariables>(PairSwapsDocument, options);
}
export type PairSwapsQueryHookResult = ReturnType<typeof usePairSwapsQuery>;
export type PairSwapsLazyQueryHookResult = ReturnType<typeof usePairSwapsLazyQuery>;
export type PairSwapsQueryResult = Apollo.QueryResult<PairSwapsQuery, PairSwapsQueryVariables>;
export function refetchPairSwapsQuery(variables?: PairSwapsQueryVariables) {
  return { query: PairSwapsDocument, variables: variables };
}
export const PairTradesDocument = gql`
  query pairTrades($where: OrderbookTrade_filter, $orderDirection: OrderDirection) {
    orderbookTrades(first: 10, orderDirection: $orderDirection, orderBy: internalID, where: $where) {
      block {
        id
        blockHash
        timestamp
      }
      internalID
      ...OrderbookTradeFragment
    }
  }
  ${OrderbookTradeFragmentFragmentDoc}
`;

/**
 * __usePairTradesQuery__
 *
 * To run a query within a React component, call `usePairTradesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePairTradesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePairTradesQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderDirection: // value for 'orderDirection'
 *   },
 * });
 */
export function usePairTradesQuery(baseOptions?: Apollo.QueryHookOptions<PairTradesQuery, PairTradesQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PairTradesQuery, PairTradesQueryVariables>(PairTradesDocument, options);
}
export function usePairTradesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<PairTradesQuery, PairTradesQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PairTradesQuery, PairTradesQueryVariables>(PairTradesDocument, options);
}
export type PairTradesQueryHookResult = ReturnType<typeof usePairTradesQuery>;
export type PairTradesLazyQueryHookResult = ReturnType<typeof usePairTradesLazyQuery>;
export type PairTradesQueryResult = Apollo.QueryResult<PairTradesQuery, PairTradesQueryVariables>;
export function refetchPairTradesQuery(variables?: PairTradesQueryVariables) {
  return { query: PairTradesDocument, variables: variables };
}
export const TransactionsDocument = gql`
  query transactions(
    $first: Int
    $orderBy: Transaction_orderBy
    $orderDirection: OrderDirection
    $where: Transaction_filter
  ) {
    transactions(first: $first, orderBy: $orderBy, orderDirection: $orderDirection, where: $where) {
      id
      internalID
      block {
        id
        blockHash
        timestamp
        txHash
      }
      data
      ...AddFragment
      ...RemoveFragment
      ...SwapFragment
      ...OrderbookTradeFragment
      ...DepositFragment
      ...WithdrawalFragment
      ...TransferFragment
      ...AccountUpdateFragment
      ...AmmUpdateFragment
      ...SignatureVerificationFragment
      ...TradeNFTFragment
      ...SwapNFTFragment
      ...WithdrawalNFTFragment
      ...TransferNFTFragment
      ...MintNFTFragment
      ...DataNFTFragment
    }
  }
  ${AddFragmentFragmentDoc}
  ${RemoveFragmentFragmentDoc}
  ${SwapFragmentFragmentDoc}
  ${OrderbookTradeFragmentFragmentDoc}
  ${DepositFragmentFragmentDoc}
  ${WithdrawalFragmentFragmentDoc}
  ${TransferFragmentFragmentDoc}
  ${AccountUpdateFragmentFragmentDoc}
  ${AmmUpdateFragmentFragmentDoc}
  ${SignatureVerificationFragmentFragmentDoc}
  ${TradeNftFragmentFragmentDoc}
  ${SwapNftFragmentFragmentDoc}
  ${WithdrawalNftFragmentFragmentDoc}
  ${TransferNftFragmentFragmentDoc}
  ${MintNftFragmentFragmentDoc}
  ${DataNftFragmentFragmentDoc}
`;

/**
 * __useTransactionsQuery__
 *
 * To run a query within a React component, call `useTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      orderBy: // value for 'orderBy'
 *      orderDirection: // value for 'orderDirection'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useTransactionsQuery(
  baseOptions?: Apollo.QueryHookOptions<TransactionsQuery, TransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<TransactionsQuery, TransactionsQueryVariables>(TransactionsDocument, options);
}
export function useTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<TransactionsQuery, TransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<TransactionsQuery, TransactionsQueryVariables>(TransactionsDocument, options);
}
export type TransactionsQueryHookResult = ReturnType<typeof useTransactionsQuery>;
export type TransactionsLazyQueryHookResult = ReturnType<typeof useTransactionsLazyQuery>;
export type TransactionsQueryResult = Apollo.QueryResult<TransactionsQuery, TransactionsQueryVariables>;
export function refetchTransactionsQuery(variables?: TransactionsQueryVariables) {
  return { query: TransactionsDocument, variables: variables };
}
export const TransactionDocument = gql`
  query transaction($id: ID!) {
    transaction(id: $id) {
      id
      internalID
      block {
        id
        blockHash
        timestamp
        transactionCount
        txHash
      }
      data
      ...AddFragment
      ...RemoveFragment
      ...SwapFragment
      ...OrderbookTradeFragment
      ...DepositFragment
      ...WithdrawalFragment
      ...TransferFragment
      ...AccountUpdateFragment
      ...AmmUpdateFragment
      ...SignatureVerificationFragment
      ...TradeNFTFragment
      ...SwapNFTFragment
      ...WithdrawalNFTFragment
      ...TransferNFTFragment
      ...MintNFTFragment
      ...DataNFTFragment
    }
  }
  ${AddFragmentFragmentDoc}
  ${RemoveFragmentFragmentDoc}
  ${SwapFragmentFragmentDoc}
  ${OrderbookTradeFragmentFragmentDoc}
  ${DepositFragmentFragmentDoc}
  ${WithdrawalFragmentFragmentDoc}
  ${TransferFragmentFragmentDoc}
  ${AccountUpdateFragmentFragmentDoc}
  ${AmmUpdateFragmentFragmentDoc}
  ${SignatureVerificationFragmentFragmentDoc}
  ${TradeNftFragmentFragmentDoc}
  ${SwapNftFragmentFragmentDoc}
  ${WithdrawalNftFragmentFragmentDoc}
  ${TransferNftFragmentFragmentDoc}
  ${MintNftFragmentFragmentDoc}
  ${DataNftFragmentFragmentDoc}
`;

/**
 * __useTransactionQuery__
 *
 * To run a query within a React component, call `useTransactionQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useTransactionQuery(baseOptions: Apollo.QueryHookOptions<TransactionQuery, TransactionQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<TransactionQuery, TransactionQueryVariables>(TransactionDocument, options);
}
export function useTransactionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<TransactionQuery, TransactionQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<TransactionQuery, TransactionQueryVariables>(TransactionDocument, options);
}
export type TransactionQueryHookResult = ReturnType<typeof useTransactionQuery>;
export type TransactionLazyQueryHookResult = ReturnType<typeof useTransactionLazyQuery>;
export type TransactionQueryResult = Apollo.QueryResult<TransactionQuery, TransactionQueryVariables>;
export function refetchTransactionQuery(variables: TransactionQueryVariables) {
  return { query: TransactionDocument, variables: variables };
}
export const PendingTransactionsDocument = gql`
  query pendingTransactions(
    $transferWhere: Transfer_filter
    $withdrawalWhere: Withdrawal_filter
    $addWhere: Add_filter
    $removeWhere: Remove_filter
    $orderBookTradeWhere: OrderbookTrade_filter
    $mintNFTWhere: MintNFT_filter
    $withdrawNFTWhere: WithdrawalNFT_filter
    $transferNFTWhere: TransferNFT_filter
    $swapWhere: Swap_filter
    $tradeNFTWhereA: TradeNFT_filter
    $tradeNFTWhereB: TradeNFT_filter
    $accountUpdateWhere: AccountUpdate_filter
  ) {
    transfers(where: $transferWhere) {
      id
    }
    withdrawals(where: $withdrawalWhere) {
      id
    }
    adds(where: $addWhere) {
      id
    }
    removes(where: $removeWhere) {
      id
    }
    orderbookTrades(where: $orderBookTradeWhere) {
      id
    }
    mintNFTs(where: $mintNFTWhere) {
      id
    }
    withdrawalNFTs(where: $withdrawNFTWhere) {
      id
    }
    transferNFTs(where: $transferNFTWhere) {
      id
    }
    swaps(where: $swapWhere) {
      id
    }
    tradeNFTs(where: $tradeNFTWhereA) {
      id
    }
    tradeNFTsB: tradeNFTs(where: $tradeNFTWhereB) {
      id
    }
    accountUpdates(where: $accountUpdateWhere) {
      id
    }
  }
`;

/**
 * __usePendingTransactionsQuery__
 *
 * To run a query within a React component, call `usePendingTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingTransactionsQuery({
 *   variables: {
 *      transferWhere: // value for 'transferWhere'
 *      withdrawalWhere: // value for 'withdrawalWhere'
 *      addWhere: // value for 'addWhere'
 *      removeWhere: // value for 'removeWhere'
 *      orderBookTradeWhere: // value for 'orderBookTradeWhere'
 *      mintNFTWhere: // value for 'mintNFTWhere'
 *      withdrawNFTWhere: // value for 'withdrawNFTWhere'
 *      transferNFTWhere: // value for 'transferNFTWhere'
 *      swapWhere: // value for 'swapWhere'
 *      tradeNFTWhereA: // value for 'tradeNFTWhereA'
 *      tradeNFTWhereB: // value for 'tradeNFTWhereB'
 *      accountUpdateWhere: // value for 'accountUpdateWhere'
 *   },
 * });
 */
export function usePendingTransactionsQuery(
  baseOptions?: Apollo.QueryHookOptions<PendingTransactionsQuery, PendingTransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<PendingTransactionsQuery, PendingTransactionsQueryVariables>(
    PendingTransactionsDocument,
    options
  );
}
export function usePendingTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<PendingTransactionsQuery, PendingTransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<PendingTransactionsQuery, PendingTransactionsQueryVariables>(
    PendingTransactionsDocument,
    options
  );
}
export type PendingTransactionsQueryHookResult = ReturnType<typeof usePendingTransactionsQuery>;
export type PendingTransactionsLazyQueryHookResult = ReturnType<typeof usePendingTransactionsLazyQuery>;
export type PendingTransactionsQueryResult = Apollo.QueryResult<
  PendingTransactionsQuery,
  PendingTransactionsQueryVariables
>;
export function refetchPendingTransactionsQuery(variables?: PendingTransactionsQueryVariables) {
  return { query: PendingTransactionsDocument, variables: variables };
}
